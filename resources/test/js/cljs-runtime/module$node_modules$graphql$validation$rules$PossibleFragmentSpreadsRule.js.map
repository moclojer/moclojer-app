{
"version":3,
"file":"module$node_modules$graphql$validation$rules$PossibleFragmentSpreadsRule.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,CAAA,wEAAA,CAA6F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,2BAAR,CAmBAA,QAAoC,CAACC,OAAD,CAAU,CAC5C,MAAO,CACLC,cAAc,CAACC,IAAD,CAAO,CACnB,IAAMC,SAAWH,OAAQI,CAAAA,OAAR,EAAjB,CACMC,WAAaL,OAAQM,CAAAA,aAAR,EAGjB,IAAIC,WAAYC,CAAAA,eAAhB,EAAiCL,QAAjC,CADF,EAEE,GAAII,WAAYC,CAAAA,eAAhB,EAAiCH,UAAjC,CAFF,EAGE,CAAC,GAAII,gBAAiBC,CAAAA,cAArB,EACCV,OAAQW,CAAAA,SAAR,EADD,CAECR,QAFD,CAGCE,UAHD,CAHH,GASQO,UAEN;AAFsB,GAAIC,QAASC,CAAAA,OAAb,EAAsBT,UAAtB,CAEtB,CADMU,QACN,CADoB,GAAIF,QAASC,CAAAA,OAAb,EAAsBX,QAAtB,CACpB,CAAAH,OAAQgB,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,sDAAqDN,UAArD,2BAA6FG,QAA7F,IADH,CAEE,CACEI,MAAOjB,IADT,CAFF,CADF,CAXF,CAJmB,CADhB,CA2BLkB,cAAc,CAAClB,IAAD,CAAO,CACnB,MAAMmB,SAAWnB,IAAKoB,CAAAA,IAAKxB,CAAAA,KACV,KAAA,wBA2BiB,EAAA,CAAA,CAGtC,GAFMyB,wBAEN,CA9BqCvB,OA4BhBwB,CAAAA,WAAR,CA5BiCH,QA4BjC,CAEb,CAME,GALMI,wBAKF,CALS,GAAIC,YAAaC,CAAAA,WAAjB,EA/BsB3B,OAgCzBW,CAAAA,SAAR,EADW,CAEXY,wBAAKK,CAAAA,aAFM,CAKT;AAAA,GAAIrB,WAAYC,CAAAA,eAAhB,EAAiCiB,wBAAjC,CAAJ,CACE,MAAA,CAVkC,yBAAA,CAAA,IAAA,EAAA,CA1BlC,IAAMpB,WAAaL,OAAQM,CAAAA,aAAR,EAGjBH,yBADF,EAEEE,UAFF,EAGE,CAAC,GAAII,gBAAiBC,CAAAA,cAArB,EACCV,OAAQW,CAAAA,SAAR,EADD,CAECR,wBAFD,CAGCE,UAHD,CAHH,GASQO,UAEN,CAFsB,GAAIC,QAASC,CAAAA,OAAb,EAAsBT,UAAtB,CAEtB,CADMU,wBACN,CADoB,GAAIF,QAASC,CAAAA,OAAb,EAAsBX,wBAAtB,CACpB,CAAAH,OAAQgB,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,aAAYG,QAAZ,+CAAmET,UAAnE,2BAA2GG,wBAA3G,IADH;AAEE,CACEI,MAAOjB,IADT,CAFF,CADF,CAXF,CALmB,CA3BhB,CADqC,CAjB9C,KAAIW,SAAWpB,OAAA,CAAQ,6CAAR,CAAf,CAEIwB,cAAgBxB,OAAA,CAAQ,gDAAR,CAFpB,CAIIc,YAAcd,OAAA,CAAQ,6CAAR,CAJlB,CAMIgB,iBAAmBhB,OAAA,CAAQ,uDAAR,CANvB,CAQIiC,aAAejC,OAAA,CAAQ,mDAAR,CAhBkH;",
"sources":["node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$PossibleFragmentSpreadsRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        (0, _definition.isCompositeType)(fragType) &&\n        (0, _definition.isCompositeType)(parentType) &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(\n      context.getSchema(),\n      frag.typeCondition,\n    );\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","PossibleFragmentSpreadsRule","context","InlineFragment","node","fragType","getType","parentType","getParentType","_definition","isCompositeType","_typeComparators","doTypesOverlap","getSchema","parentTypeStr","_inspect","inspect","fragTypeStr","reportError","_GraphQLError","GraphQLError","nodes","FragmentSpread","fragName","name","frag","getFragment","type","_typeFromAST","typeFromAST","typeCondition"]
}
