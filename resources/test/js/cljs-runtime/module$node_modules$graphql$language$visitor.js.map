{
"version":3,
"file":"module$node_modules$graphql$language$visitor.js",
"lineCount":9,
"mappings":"AAAAA,cAAA,CAAA,4CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA0VzGC,QAASA,qBAAoB,CAACC,OAAD,CAAUC,IAAV,CAAgB,CACrCC,IAAAA,CAAcF,OAAA,CAAQC,IAAR,CAEpB,OAA2B,QAA3B,GAAI,MAAOC,KAAX,CAESA,IAFT,CAGkC,UAA3B,GAAI,MAAOA,KAAX,CAEE,CACLC,MAAOD,IADF,CAELE,MAAOC,IAAAA,EAFF,CAFF,CAQA,CACLF,MAAOH,OAAQG,CAAAA,KADV,CAELC,MAAOJ,OAAQI,CAAAA,KAFV,CAdoC,CAvV7CE,MAAOC,CAAAA,cAAP,CAAsBT,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CU,MAAO,CAAA,CADoC,CAA7C,CAGAV,QAAQW,CAAAA,KAAR,CAAgB,IAAK,EACrBX,QAAQC,CAAAA,oBAAR,CAA+BA,oBAC/BD,QAAQY,CAAAA,UAAR,CA8WAA,QAAmB,CAACV,OAAD,CAAUC,IAAV,CAAgBU,SAAhB,CAA2B,CAC5C,MAAM,CAAER,KAAF,CAASC,KAAT,CAAA,CAAmBL,oBAAA,CAAqBC,OAArB;AAA8BC,IAA9B,CACzB,OAAOU,UAAA,CAAYP,KAAZ,CAAoBD,KAFiB,CA7W9CL,QAAQc,CAAAA,KAAR,CA6FAA,QAAc,CAACC,IAAD,CAAOb,OAAP,CAAgBc,WAAA,CAAcC,IAAKC,CAAAA,iBAAnC,CAAsD,CAClE,MAAMC,cAAgB,IAAIC,GAE1B,KAAK,IAAMjB,IAAX,GAAmBK,OAAOa,CAAAA,MAAP,CAAcC,MAAOC,CAAAA,IAArB,CAAnB,CACEJ,aAAcK,CAAAA,GAAd,CAAkBrB,IAAlB,CAAwBF,oBAAA,CAAqBC,OAArB,CAA8BC,IAA9B,CAAxB,CAIEsB,KAAAA,CAAQlB,IAAAA,EACZ,KAAImB,QAAUC,KAAMC,CAAAA,OAAN,CAAcb,IAAd,CACd,KAAIc,KAAO,CAACd,IAAD,CAAX,CACIe,MAAQ,CAAC,CACb,KAAIC,MAAQ,EACZ,KAAIC,KAAOjB,IAAX,CACIkB,IAAM1B,IAAAA,EADV,CAEI2B,OAAS3B,IAAAA,EACb,OAAM4B,KAAO,EAAb,CACMC,UAAY,EAGlB,GAAG,CACDN,KAAA,EACA,OAAMjB,UAAYiB,KAAZjB,GAAsBgB,IAAKQ,CAAAA,MAAjC,CACMC,SAAWzB,SAAXyB,EAAyC,CAAzCA,GAAwBP,KAAMM,CAAAA,MAEpC,IAAIxB,SAAJ,CAAe,CACboB,GAAA,CAA2B,CAArB,GAAAG,SAAUC,CAAAA,MAAV;AAAyB9B,IAAAA,EAAzB,CAAqC4B,IAAA,CAAKA,IAAKE,CAAAA,MAAV,CAAmB,CAAnB,CAC3CL,KAAA,CAAOE,MACPA,OAAA,CAASE,SAAUG,CAAAA,GAAV,EAET,IAAID,QAAJ,CACE,GAAIZ,OAAJ,CAAa,CACXM,IAAA,CAAOA,IAAKQ,CAAAA,KAAL,EACHC,QAAAA,CAAa,CAEjB,KAAK,MAAM,CAACC,OAAD,CAAUC,SAAV,CAAX,EAAmCZ,MAAnC,CACQa,KAEN,CAFiBF,OAEjB,CAF2BD,OAE3B,CAAkB,IAAlB,GAAIE,SAAJ,EACEX,IAAKa,CAAAA,MAAL,CAAYD,KAAZ,CAAsB,CAAtB,CACA,CAAAH,OAAA,EAFF,EAIET,IAAA,CAAKY,KAAL,CAJF,CAImBD,SAXV,CAAb,IAcO,CACLX,IAAA,CAAOxB,MAAOsC,CAAAA,gBAAP,CACL,EADK,CAELtC,MAAOuC,CAAAA,yBAAP,CAAiCf,IAAjC,CAFK,CAKP,KAAK,MAAM,CAACU,OAAD,CAAUC,SAAV,CAAX,EAAmCZ,MAAnC,CACEC,IAAA,CAAKU,OAAL,CAAA,CAAgBC,SAPb,CAYTb,KAAA,CAAQL,IAAMK,CAAAA,KACdD,KAAA,CAAOJ,IAAMI,CAAAA,IACbE,MAAA,CAAQN,IAAMM,CAAAA,KACdL,QAAA,CAAUD,IAAMC,CAAAA,OAChBD,KAAA,CAAQA,IAAMuB,CAAAA,IApCD,CAAf,IAqCO,IAAId,MAAJ,CAAY,CACjBD,GAAA,CAAMP,OAAA,CAAUI,KAAV;AAAkBD,IAAA,CAAKC,KAAL,CACxBE,KAAA,CAAOE,MAAA,CAAOD,GAAP,CAEP,IAAa,IAAb,GAAID,IAAJ,EAA8BzB,IAAAA,EAA9B,GAAqByB,IAArB,CACE,QAGFG,KAAKc,CAAAA,IAAL,CAAUhB,GAAV,CARiB,CAWnB,IAAIiB,OAAAA,IAAAA,EAEJ,IAAI,CAACvB,KAAMC,CAAAA,OAAN,CAAcI,IAAd,CAAL,CAA0B,CAAA,IACpBmB,kBADoB,CACAC,mBAExB,IAAInC,IAAKoC,CAAAA,MAAT,EAAiBrB,IAAjB,CAAA,EACE,GAAIsB,UAAWC,CAAAA,SAAf,EACE,CAAA,CADF,CAEG,qBAAoB,GAAIC,QAASC,CAAAA,OAAb,EAAsBzB,IAAtB,CAApB,GAFH,CAII0B,OAAAA,CAAU7C,SAAA,CAC4C,IAAxD,IAACsC,kBAAD,CAAsBhC,aAAcwC,CAAAA,GAAd,CAAkB3B,IAAK7B,CAAAA,IAAvB,CAAtB,GACuB,IAAK,EAD5B,GACAgD,kBADA,CAEE,IAAK,EAFP,CAGEA,kBAAmB7C,CAAAA,KAJT,CAK6C,IAAzD,IAAC8C,mBAAD,CAAuBjC,aAAcwC,CAAAA,GAAd,CAAkB3B,IAAK7B,CAAAA,IAAvB,CAAvB,GACwB,IAAK,EAD7B,GACAiD,mBADA,CAEA,IAAK,EAFL;AAGAA,mBAAoB/C,CAAAA,KACxB6C,OAAA,CACc,IAAZ,GAAAQ,MAAA,EAAgC,IAAK,EAArC,GAAoBA,MAApB,CACI,IAAK,EADT,CAEIA,MAAQE,CAAAA,IAAR,CAAa1D,OAAb,CAAsB8B,IAAtB,CAA4BC,GAA5B,CAAiCC,MAAjC,CAAyCC,IAAzC,CAA+CC,SAA/C,CAEN,IAAIc,MAAJ,GAAevC,KAAf,CACE,KAGF,IAAe,CAAA,CAAf,GAAIuC,MAAJ,CACE,IAAI,CAACrC,SAAL,CAAgB,CACdsB,IAAKI,CAAAA,GAAL,EACA,SAFc,CAAhB,CADF,IAKO,IAAehC,IAAAA,EAAf,GAAI2C,MAAJ,GACLnB,KAAMkB,CAAAA,IAAN,CAAW,CAAChB,GAAD,CAAMiB,MAAN,CAAX,CAEI,CAAA,CAACrC,SAHA,EAIH,GAAI,GAAII,IAAKoC,CAAAA,MAAT,EAAiBH,MAAjB,CAAJ,CACElB,IAAA,CAAOkB,MADT,KAEO,CACLf,IAAKI,CAAAA,GAAL,EACA,SAFK,CArCa,CA6CXhC,IAAAA,EAAf,GAAI2C,MAAJ,EAA4BZ,QAA5B,EACEP,KAAMkB,CAAAA,IAAN,CAAW,CAAChB,GAAD,CAAMD,IAAN,CAAX,CAGF,IAAInB,SAAJ,CACEsB,IAAKI,CAAAA,GAAL,EADF,KAEO,CACL,IAAIsB,UAEJpC,KAAA,CAAQ,CACNC,OADM,CAENI,KAFM,CAGND,IAHM,CAINE,KAJM,CAKNiB,KAAMvB,IALA,CAQRI,KAAA,CAAO,CADPH,OACO,CADGC,KAAMC,CAAAA,OAAN,CAAcI,IAAd,CACH,EACHA,IADG;AAEuC,IAA1C,IAAC6B,UAAD,CAAc7C,WAAA,CAAYgB,IAAK7B,CAAAA,IAAjB,CAAd,GACe,IAAK,EADpB,GACA0D,UADA,CAEAA,UAFA,CAGA,EACJ/B,MAAA,CAAQ,CAAC,CACTC,MAAA,CAAQ,EAEJG,OAAJ,EACEE,SAAUa,CAAAA,IAAV,CAAef,MAAf,CAGFA,OAAA,CAASF,IAxBJ,CA1GN,CAAH,MAoImBzB,IAAAA,EApInB,GAoISkB,IApIT,CAsIA,OAAqB,EAArB,GAAIM,KAAMM,CAAAA,MAAV,CAESN,KAAA,CAAMA,KAAMM,CAAAA,MAAZ,CAAqB,CAArB,CAAA,CAAwB,CAAxB,CAFT,CAKOtB,IA/J2D,CA5FpEf,QAAQ8D,CAAAA,eAAR,CAoQAA,QAAwB,CAACC,QAAD,CAAW,CACjC,MAAMC,SAAerC,KAAJ,CAAUoC,QAAS1B,CAAAA,MAAnB,CAA2B4B,CAAAA,IAA3B,CAAgC,IAAhC,CAAjB,CACMC,cAAgB1D,MAAO2D,CAAAA,MAAP,CAAc,IAAd,CAEtB,KAAK,MAAMhE,IAAX,GAAmBK,OAAOa,CAAAA,MAAP,CAAcC,MAAOC,CAAAA,IAArB,CAAnB,CAA+C,CAC7C,IAAI6C,WAAa,CAAA,CACjB,OAAMC,UAAgB1C,KAAJ,CAAUoC,QAAS1B,CAAAA,MAAnB,CAA2B4B,CAAAA,IAA3B,CAAgC1D,IAAAA,EAAhC,CAAlB,CACM+D,UAAgB3C,KAAJ,CAAUoC,QAAS1B,CAAAA,MAAnB,CAA2B4B,CAAAA,IAA3B,CAAgC1D,IAAAA,EAAhC,CAElB;IAAK,IAAIgE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBR,QAAS1B,CAAAA,MAA7B,CAAqC,EAAEkC,CAAvC,CAA0C,CACxC,MAAM,CAAElE,KAAF,CAASC,KAAT,CAAA,CAAmBL,oBAAA,CAAqB8D,QAAA,CAASQ,CAAT,CAArB,CAAkCpE,IAAlC,CACzBiE,WAAA,GAAeA,UAAf,CAAqC,IAArC,EAA4B/D,KAA5B,EAAsD,IAAtD,EAA6CC,KAA7C,CACA+D,UAAA,CAAUE,CAAV,CAAA,CAAelE,KACfiE,UAAA,CAAUC,CAAV,CAAA,CAAejE,KAJyB,CAOrC8D,UAAL,GAmDAF,aAAA,CAAc/D,IAAd,CAnDA,CAIyBqE,CACvBnE,KAAK,CAAC,GAAGoE,IAAJ,CAAU,CACb,MAAMzC,KAAOyC,IAAA,CAAK,CAAL,CAEb,KAAK,IAAIF,EAAI,CAAb,CAAgBA,CAAhB,CAAoBR,QAAS1B,CAAAA,MAA7B,CAAqCkC,CAAA,EAArC,CACE,GAAoB,IAApB,GAAIP,QAAA,CAASO,CAAT,CAAJ,CAA0B,CACxB,IAAIG,YAEJ,OAAMxB,OAC8B,IAAlC,IAACwB,YAAD,CAAgBL,SAAA,CAAUE,CAAV,CAAhB,GAA2D,IAAK,EAAhE,GAA0CG,YAA1C,CACI,IAAK,EADT,CAEIA,YAAaC,CAAAA,KAAb,CAAmBZ,QAAA,CAASQ,CAAT,CAAnB,CAAgCE,IAAhC,CAEN,IAAe,CAAA,CAAf,GAAIvB,MAAJ,CACEc,QAAA,CAASO,CAAT,CAAA,CAAcvC,IADhB,KAEO,IAAIkB,MAAJ,GAAevC,KAAf,CACLqD,QAAA,CAASO,CAAT,CAAA;AAAc5D,KADT,KAEA,IAAeJ,IAAAA,EAAf,GAAI2C,MAAJ,CACL,MAAOA,OAbe,CAJf,CADQsB,CAwBvBlE,KAAK,CAAC,GAAGmE,IAAJ,CAAU,CACb,MAAMzC,KAAOyC,IAAA,CAAK,CAAL,CAEb,KAAK,IAAIF,EAAI,CAAb,CAAgBA,CAAhB,CAAoBR,QAAS1B,CAAAA,MAA7B,CAAqCkC,CAAA,EAArC,CACE,GAAoB,IAApB,GAAIP,QAAA,CAASO,CAAT,CAAJ,CAA0B,CACxB,IAAIK,YAEJ,OAAM1B,OAC8B,IAAlC,IAAC0B,YAAD,CAAgBN,SAAA,CAAUC,CAAV,CAAhB,GAA2D,IAAK,EAAhE,GAA0CK,YAA1C,CACI,IAAK,EADT,CAEIA,YAAaD,CAAAA,KAAb,CAAmBZ,QAAA,CAASQ,CAAT,CAAnB,CAAgCE,IAAhC,CAEN,IAAIvB,MAAJ,GAAevC,KAAf,CACEqD,QAAA,CAASO,CAAT,CAAA,CAAc5D,KADhB,KAEO,IAAeJ,IAAAA,EAAf,GAAI2C,MAAJ,EAAuC,CAAA,CAAvC,GAA4BA,MAA5B,CACL,MAAOA,OAXe,CAA1B,IAaWc,SAAA,CAASO,CAAT,CAAJ,GAAoBvC,IAApB,GACLgC,QAAA,CAASO,CAAT,CADK,CACS,IADT,CAjBI,CAxBQC,CAJzB,CAZ6C,CAkE/C,MAAON,cAtE0B,CAlQnC,KAAIZ,WAAaxD,OAAA,CAAQ,+CAAR,CAAjB,CAEI0D;AAAW1D,OAAA,CAAQ,6CAAR,CAFf,CAIImB,KAAOnB,OAAA,CAAQ,0CAAR,CAJX,CAMIwB,OAASxB,OAAA,CAAQ,4CAAR,CAEb,OAAMa,MAAQH,MAAOqE,CAAAA,MAAP,CAAc,EAAd,CAgFd7E,QAAQW,CAAAA,KAAR,CAAgBA,KApGyF;",
"sources":["node_modules/graphql/language/visitor.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$language$visitor\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.BREAK = void 0;\nexports.getEnterLeaveForKind = getEnterLeaveForKind;\nexports.getVisitFn = getVisitFn;\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _ast = require('./ast.js');\n\nvar _kinds = require('./kinds.js');\n\nconst BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\n\nexports.BREAK = BREAK;\n\nfunction visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {\n  const enterLeaveMap = new Map();\n\n  for (const kind of Object.values(_kinds.Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties(\n            {},\n            Object.getOwnPropertyDescriptors(node),\n          );\n\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      path.push(key);\n    }\n\n    let result;\n\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n\n      (0, _ast.isNode)(node) ||\n        (0, _devAssert.devAssert)(\n          false,\n          `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`,\n        );\n      const visitFn = isLeaving\n        ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get === void 0\n          ? void 0\n          : _enterLeaveMap$get.leave\n        : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get2 === void 0\n        ? void 0\n        : _enterLeaveMap$get2.enter;\n      result =\n        visitFn === null || visitFn === void 0\n          ? void 0\n          : visitFn.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n\n        if (!isLeaving) {\n          if ((0, _ast.isNode)(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack,\n      };\n      inArray = Array.isArray(node);\n      keys = inArray\n        ? node\n        : (_node$kind = visitorKeys[node.kind]) !== null &&\n          _node$kind !== void 0\n        ? _node$kind\n        : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n\n  return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nfunction visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(_kinds.Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave = {\n      enter(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n\n            const result =\n              (_enterList$i = enterList[i]) === null || _enterList$i === void 0\n                ? void 0\n                : _enterList$i.apply(visitors[i], args);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n\n      leave(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n\n            const result =\n              (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0\n                ? void 0\n                : _leaveList$i.apply(visitors[i], args);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      },\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\n\nfunction getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined,\n    };\n  } // { enter() {}, leave() {} }\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave,\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\n\n/* c8 ignore next 8 */\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getEnterLeaveForKind","visitor","kind","kindVisitor","enter","leave","undefined","Object","defineProperty","value","BREAK","getVisitFn","isLeaving","visit","root","visitorKeys","_ast","QueryDocumentKeys","enterLeaveMap","Map","values","_kinds","Kind","set","stack","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","length","isEdited","pop","slice","editOffset","editKey","editValue","arrayKey","splice","defineProperties","getOwnPropertyDescriptors","prev","push","result","_enterLeaveMap$get","_enterLeaveMap$get2","isNode","_devAssert","devAssert","_inspect","inspect","visitFn","get","call","_node$kind","visitInParallel","visitors","skipping","fill","mergedVisitor","create","hasVisitor","enterList","leaveList","i","mergedEnterLeave","args","_enterList$i","apply","_leaveList$i","freeze"]
}
