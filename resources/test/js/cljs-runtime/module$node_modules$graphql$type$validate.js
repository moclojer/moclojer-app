shadow$provide.module$node_modules$graphql$type$validate=function(global,require,module,exports){function validateSchema(schema$jscomp$0){(0,_schema.assertSchema)(schema$jscomp$0);if(schema$jscomp$0.__validationErrors)return schema$jscomp$0.__validationErrors;var context=new SchemaValidationContext(schema$jscomp$0),schema=context.schema,queryType=schema.getQueryType();if(!queryType)context.reportError("Query root type must be provided.",schema.astNode);else if(!(0,_definition.isObjectType)(queryType)){var _getOperationTypeNode;
context.reportError(`Query root type must be Object type, it cannot be ${(0,_inspect.inspect)(queryType)}.`,null!==(_getOperationTypeNode=getOperationTypeNode(schema,_ast.OperationTypeNode.QUERY))&&void 0!==_getOperationTypeNode?_getOperationTypeNode:queryType.astNode)}if((queryType=schema.getMutationType())&&!(0,_definition.isObjectType)(queryType)){var _getOperationTypeNode2;context.reportError("Mutation root type must be Object type if provided, it cannot be "+`${(0,_inspect.inspect)(queryType)}.`,
null!==(_getOperationTypeNode2=getOperationTypeNode(schema,_ast.OperationTypeNode.MUTATION))&&void 0!==_getOperationTypeNode2?_getOperationTypeNode2:queryType.astNode)}if((_getOperationTypeNode2=schema.getSubscriptionType())&&!(0,_definition.isObjectType)(_getOperationTypeNode2)){var _getOperationTypeNode3;context.reportError("Subscription root type must be Object type if provided, it cannot be "+`${(0,_inspect.inspect)(_getOperationTypeNode2)}.`,null!==(_getOperationTypeNode3=getOperationTypeNode(schema,
_ast.OperationTypeNode.SUBSCRIPTION))&&void 0!==_getOperationTypeNode3?_getOperationTypeNode3:_getOperationTypeNode2.astNode)}for(var directive of context.schema.getDirectives())if((0,_directives.isDirective)(directive)){validateName(context,directive);for(var arg of directive.args)if(validateName(context,arg),(0,_definition.isInputType)(arg.type)||context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type `+`but got: ${(0,_inspect.inspect)(arg.type)}.`,arg.astNode),(0,_definition.isRequiredArgument)(arg)&&
null!=arg.deprecationReason){var _arg$astNode;context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,[getDeprecatedDirectiveNode(arg.astNode),null===(_arg$astNode=arg.astNode)||void 0===_arg$astNode?void 0:_arg$astNode.type])}}else context.reportError(`Expected directive but got: ${(0,_inspect.inspect)(directive)}.`,null===directive||void 0===directive?void 0:directive.astNode);schema=createInputObjectCircularRefsValidator(context);_getOperationTypeNode3=context.schema.getTypeMap();
for(const type of Object.values(_getOperationTypeNode3))if((0,_definition.isNamedType)(type))if((0,_introspection.isIntrospectionType)(type)||validateName(context,type),(0,_definition.isObjectType)(type))validateFields(context,type),validateInterfaces(context,type);else if((0,_definition.isInterfaceType)(type))validateFields(context,type),validateInterfaces(context,type);else if((0,_definition.isUnionType)(type)){_getOperationTypeNode3=context;_arg$astNode=type;directive=_arg$astNode.getTypes();0===
directive.length&&_getOperationTypeNode3.reportError(`Union type ${_arg$astNode.name} must define one or more member types.`,[_arg$astNode.astNode,..._arg$astNode.extensionASTNodes]);arg=Object.create(null);for(const memberType of directive)arg[memberType.name]?_getOperationTypeNode3.reportError(`Union type ${_arg$astNode.name} can only include type ${memberType.name} once.`,getUnionMemberTypeNodes(_arg$astNode,memberType.name)):(arg[memberType.name]=!0,(0,_definition.isObjectType)(memberType)||_getOperationTypeNode3.reportError(`Union type ${_arg$astNode.name} can only include Object types, `+
`it cannot include ${(0,_inspect.inspect)(memberType)}.`,getUnionMemberTypeNodes(_arg$astNode,String(memberType))))}else if((0,_definition.isEnumType)(type)){_getOperationTypeNode3=context;_arg$astNode=type;directive=_arg$astNode.getValues();0===directive.length&&_getOperationTypeNode3.reportError(`Enum type ${_arg$astNode.name} must define one or more values.`,[_arg$astNode.astNode,..._arg$astNode.extensionASTNodes]);for(const enumValue of directive)validateName(_getOperationTypeNode3,enumValue)}else{if((0,_definition.isInputObjectType)(type)){_getOperationTypeNode3=
context;_arg$astNode=type;directive=Object.values(_arg$astNode.getFields());0===directive.length&&_getOperationTypeNode3.reportError(`Input Object type ${_arg$astNode.name} must define one or more fields.`,[_arg$astNode.astNode,..._arg$astNode.extensionASTNodes]);for(const field of directive){validateName(_getOperationTypeNode3,field);if(!(0,_definition.isInputType)(field.type)){var _field$astNode2;_getOperationTypeNode3.reportError(`The type of ${_arg$astNode.name}.${field.name} must be Input Type `+
`but got: ${(0,_inspect.inspect)(field.type)}.`,null===(_field$astNode2=field.astNode)||void 0===_field$astNode2?void 0:_field$astNode2.type)}if((0,_definition.isRequiredInputField)(field)&&null!=field.deprecationReason){var _field$astNode3;_getOperationTypeNode3.reportError(`Required input field ${_arg$astNode.name}.${field.name} cannot be deprecated.`,[getDeprecatedDirectiveNode(field.astNode),null===(_field$astNode3=field.astNode)||void 0===_field$astNode3?void 0:_field$astNode3.type])}}schema(type)}}else context.reportError(`Expected GraphQL named type but got: ${(0,_inspect.inspect)(type)}.`,
type.astNode);context=context.getErrors();return schema$jscomp$0.__validationErrors=context}function getOperationTypeNode(schema,operation){var _flatMap$find;return null===(_flatMap$find=[schema.astNode,...schema.extensionASTNodes].flatMap(schemaNode=>{var _schemaNode$operation;return null!==(_schemaNode$operation=null===schemaNode||void 0===schemaNode?void 0:schemaNode.operationTypes)&&void 0!==_schemaNode$operation?_schemaNode$operation:[]}).find(operationNode=>operationNode.operation===operation))||
void 0===_flatMap$find?void 0:_flatMap$find.type}function validateName(context,node){node.name.startsWith("__")&&context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,node.astNode)}function validateFields(context,type){var fields=Object.values(type.getFields());0===fields.length&&context.reportError(`Type ${type.name} must define one or more fields.`,[type.astNode,...type.extensionASTNodes]);for(const field of fields){validateName(context,
field);if(!(0,_definition.isOutputType)(field.type)){var _field$astNode;context.reportError(`The type of ${type.name}.${field.name} must be Output Type `+`but got: ${(0,_inspect.inspect)(field.type)}.`,null===(_field$astNode=field.astNode)||void 0===_field$astNode?void 0:_field$astNode.type)}for(const arg of field.args){fields=arg.name;validateName(context,arg);if(!(0,_definition.isInputType)(arg.type)){var _arg$astNode2;context.reportError(`The type of ${type.name}.${field.name}(${fields}:) must be Input `+
`Type but got: ${(0,_inspect.inspect)(arg.type)}.`,null===(_arg$astNode2=arg.astNode)||void 0===_arg$astNode2?void 0:_arg$astNode2.type)}if((0,_definition.isRequiredArgument)(arg)&&null!=arg.deprecationReason){var _arg$astNode3;context.reportError(`Required argument ${type.name}.${field.name}(${fields}:) cannot be deprecated.`,[getDeprecatedDirectiveNode(arg.astNode),null===(_arg$astNode3=arg.astNode)||void 0===_arg$astNode3?void 0:_arg$astNode3.type])}}}}function validateInterfaces(context$jscomp$0,
type$jscomp$0){const ifaceTypeNames=Object.create(null);for(const iface of type$jscomp$0.getInterfaces()){if(!(0,_definition.isInterfaceType)(iface)){context$jscomp$0.reportError(`Type ${(0,_inspect.inspect)(type$jscomp$0)} must only implement Interface types, `+`it cannot implement ${(0,_inspect.inspect)(iface)}.`,getAllImplementsInterfaceNodes(type$jscomp$0,iface));continue}if(type$jscomp$0===iface){context$jscomp$0.reportError(`Type ${type$jscomp$0.name} cannot implement itself because it would create a circular reference.`,
getAllImplementsInterfaceNodes(type$jscomp$0,iface));continue}if(ifaceTypeNames[iface.name]){context$jscomp$0.reportError(`Type ${type$jscomp$0.name} can only implement ${iface.name} once.`,getAllImplementsInterfaceNodes(type$jscomp$0,iface));continue}ifaceTypeNames[iface.name]=!0;var context=context$jscomp$0,type=type$jscomp$0,iface$jscomp$0=iface;const ifaceInterfaces=type.getInterfaces();for(const transitive of iface$jscomp$0.getInterfaces())ifaceInterfaces.includes(transitive)||context.reportError(transitive===
type?`Type ${type.name} cannot implement ${iface$jscomp$0.name} because it would create a circular reference.`:`Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface$jscomp$0.name}.`,[...getAllImplementsInterfaceNodes(iface$jscomp$0,transitive),...getAllImplementsInterfaceNodes(type,iface$jscomp$0)]);validateTypeImplementsInterface(context$jscomp$0,type$jscomp$0,iface)}}function validateTypeImplementsInterface(context,type,iface){const typeFieldMap=type.getFields();
for(const ifaceField of Object.values(iface.getFields())){const fieldName=ifaceField.name,typeField=typeFieldMap[fieldName];if(typeField){if(!(0,_typeComparators.isTypeSubTypeOf)(context.schema,typeField.type,ifaceField.type)){var _ifaceField$astNode,_typeField$astNode;context.reportError(`Interface field ${iface.name}.${fieldName} expects type `+`${(0,_inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} `+`is type ${(0,_inspect.inspect)(typeField.type)}.`,[null===(_ifaceField$astNode=
ifaceField.astNode)||void 0===_ifaceField$astNode?void 0:_ifaceField$astNode.type,null===(_typeField$astNode=typeField.astNode)||void 0===_typeField$astNode?void 0:_typeField$astNode.type])}for(const ifaceArg of ifaceField.args){const argName=ifaceArg.name,typeArg=typeField.args.find(arg=>arg.name===argName);if(!typeArg)context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,[ifaceArg.astNode,typeField.astNode]);
else if(!(0,_typeComparators.isEqualType)(ifaceArg.type,typeArg.type)){var _ifaceArg$astNode,_typeArg$astNode;context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) `+`expects type ${(0,_inspect.inspect)(ifaceArg.type)} but `+`${type.name}.${fieldName}(${argName}:) is type `+`${(0,_inspect.inspect)(typeArg.type)}.`,[null===(_ifaceArg$astNode=ifaceArg.astNode)||void 0===_ifaceArg$astNode?void 0:_ifaceArg$astNode.type,null===(_typeArg$astNode=typeArg.astNode)||void 0===
_typeArg$astNode?void 0:_typeArg$astNode.type])}}for(const typeArg of typeField.args){const argName=typeArg.name;!ifaceField.args.find(arg=>arg.name===argName)&&(0,_definition.isRequiredArgument)(typeArg)&&context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,[typeArg.astNode,ifaceField.astNode])}}else context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
[ifaceField.astNode,type.astNode,...type.extensionASTNodes])}}function createInputObjectCircularRefsValidator(context){function detectCycleRecursive(inputObj){if(!visitedTypes[inputObj.name]){visitedTypes[inputObj.name]=!0;fieldPathIndexByTypeName[inputObj.name]=fieldPath.length;var fields=Object.values(inputObj.getFields());for(const field of fields)if((0,_definition.isNonNullType)(field.type)&&(0,_definition.isInputObjectType)(field.type.ofType)){fields=field.type.ofType;var cycleIndex=fieldPathIndexByTypeName[fields.name];
fieldPath.push(field);if(void 0===cycleIndex)detectCycleRecursive(fields);else{cycleIndex=fieldPath.slice(cycleIndex);const pathStr=cycleIndex.map(fieldObj=>fieldObj.name).join(".");context.reportError(`Cannot reference Input Object "${fields.name}" within itself through a series of non-null fields: "${pathStr}".`,cycleIndex.map(fieldObj=>fieldObj.astNode))}fieldPath.pop()}fieldPathIndexByTypeName[inputObj.name]=void 0}}const visitedTypes=Object.create(null),fieldPath=[],fieldPathIndexByTypeName=
Object.create(null);return detectCycleRecursive}function getAllImplementsInterfaceNodes(type,iface){const {astNode,extensionASTNodes}=type;return(null!=astNode?[astNode,...extensionASTNodes]:extensionASTNodes).flatMap(typeNode=>{var _typeNode$interfaces;return null!==(_typeNode$interfaces=typeNode.interfaces)&&void 0!==_typeNode$interfaces?_typeNode$interfaces:[]}).filter(ifaceNode=>ifaceNode.name.value===iface.name)}function getUnionMemberTypeNodes(union,typeName){const {astNode,extensionASTNodes}=
union;return(null!=astNode?[astNode,...extensionASTNodes]:extensionASTNodes).flatMap(unionNode=>{var _unionNode$types;return null!==(_unionNode$types=unionNode.types)&&void 0!==_unionNode$types?_unionNode$types:[]}).filter(typeNode=>typeNode.name.value===typeName)}function getDeprecatedDirectiveNode(definitionNode){var _definitionNode$direc;return null===definitionNode||void 0===definitionNode?void 0:null===(_definitionNode$direc=definitionNode.directives)||void 0===_definitionNode$direc?void 0:_definitionNode$direc.find(node=>
node.name.value===_directives.GraphQLDeprecatedDirective.name)}Object.defineProperty(exports,"__esModule",{value:!0});exports.assertValidSchema=function(schema){schema=validateSchema(schema);if(0!==schema.length)throw Error(schema.map(error=>error.message).join("\n\n"));};exports.validateSchema=validateSchema;var _inspect=require("module$node_modules$graphql$jsutils$inspect"),_GraphQLError=require("module$node_modules$graphql$error$GraphQLError"),_ast=require("module$node_modules$graphql$language$ast"),
_typeComparators=require("module$node_modules$graphql$utilities$typeComparators"),_definition=require("module$node_modules$graphql$type$definition"),_directives=require("module$node_modules$graphql$type$directives"),_introspection=require("module$node_modules$graphql$type$introspection"),_schema=require("module$node_modules$graphql$type$schema");class SchemaValidationContext{constructor(schema){this._errors=[];this.schema=schema}reportError(message,nodes){nodes=Array.isArray(nodes)?nodes.filter(Boolean):
nodes;this._errors.push(new _GraphQLError.GraphQLError(message,{nodes}))}getErrors(){return this._errors}}}
//# sourceMappingURL=module$node_modules$graphql$type$validate.js.map
