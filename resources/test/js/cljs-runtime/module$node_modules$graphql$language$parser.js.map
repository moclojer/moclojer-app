{
"version":3,
"file":"module$node_modules$graphql$language$parser.js",
"lineCount":42,
"mappings":"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",
"sources":["node_modules/graphql/language/parser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$language$parser\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.Parser = void 0;\nexports.parse = parse;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseValue = parseValue;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _directiveLocation = require('./directiveLocation.js');\n\nvar _kinds = require('./kinds.js');\n\nvar _lexer = require('./lexer.js');\n\nvar _source = require('./source.js');\n\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nfunction parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nclass Parser {\n  constructor(source, options = {}) {\n    const sourceObj = (0, _source.isSource)(source)\n      ? source\n      : new _source.Source(source);\n    this._lexer = new _lexer.Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return this.node(token, {\n      kind: _kinds.Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(\n        _tokenKind.TokenKind.SOF,\n        this.parseDefinition,\n        _tokenKind.TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw (0, _syntaxError.syntaxError)(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: _ast.OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return _ast.OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return _ast.OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return _ast.OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type:\n        (this.expectToken(_tokenKind.TokenKind.COLON),\n        this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(\n        _tokenKind.TokenKind.BRACE_L,\n        this.parseSelection,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      item,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case _tokenKind.TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: _kinds.Kind.INT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case _tokenKind.TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: _kinds.Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: _kinds.Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case _tokenKind.TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(_tokenKind.TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw (0, _syntaxError.syntaxError)(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.LIST,\n      values: this.any(\n        _tokenKind.TokenKind.BRACKET_L,\n        item,\n        _tokenKind.TokenKind.BRACKET_R,\n      ),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(\n        _tokenKind.TokenKind.BRACE_L,\n        item,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return this.node(start, {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return (\n      this.peek(_tokenKind.TokenKind.STRING) ||\n      this.peek(_tokenKind.TokenKind.BLOCK_STRING)\n    );\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n      ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(\n      _tokenKind.TokenKind.PIPE,\n      this.parseDirectiveLocation,\n    );\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (\n      Object.prototype.hasOwnProperty.call(\n        _directiveLocation.DirectiveLocation,\n        name.value,\n      )\n    ) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new _ast.Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== _tokenKind.TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw (0, _syntaxError.syntaxError)(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nexports.Parser = Parser;\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return (0, _lexer.isPunctuatorTokenKind)(kind) ? `\"${kind}\"` : kind;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getTokenDesc","token","value","getTokenKindDesc","kind","_lexer","isPunctuatorTokenKind","Object","defineProperty","Parser","parse","source","options","parseDocument","parser","parseConstValue","expectToken","_tokenKind","TokenKind","SOF","parseConstValueLiteral","EOF","parseType","type","parseTypeReference","parseValue","parseValueLiteral","_syntaxError","_ast","_directiveLocation","_kinds","_source","constructor","sourceObj","isSource","Source","Lexer","_options","_tokenCounter","parseName","NAME","node","Kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","syntaxError","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","OperationTypeNode","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advanceLexer","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","LIST","values","any","BRACKET_R","OBJECT","fields","parseObjectField","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","prototype","hasOwnProperty","call","DirectiveLocation","startToken","noLocation","loc","Location","lastToken","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","maxTokens","advance"]
}
