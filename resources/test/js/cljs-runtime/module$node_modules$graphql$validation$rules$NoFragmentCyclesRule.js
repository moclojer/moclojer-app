shadow$provide.module$node_modules$graphql$validation$rules$NoFragmentCyclesRule=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.NoFragmentCyclesRule=function(context){function detectCycleRecursive(fragment){if(!visitedFrags[fragment.name.value]){var fragmentName=fragment.name.value;visitedFrags[fragmentName]=!0;fragment=context.getFragmentSpreads(fragment.selectionSet);if(0!==fragment.length){spreadPathIndexByName[fragmentName]=spreadPath.length;
for(const spreadNode of fragment){fragment=spreadNode.name.value;var cycleIndex=spreadPathIndexByName[fragment];spreadPath.push(spreadNode);if(void 0===cycleIndex)(fragment=context.getFragment(fragment))&&detectCycleRecursive(fragment);else{cycleIndex=spreadPath.slice(cycleIndex);const viaPath=cycleIndex.slice(0,-1).map(s=>'"'+s.name.value+'"').join(", ");context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${fragment}" within itself`+(""!==viaPath?` via ${viaPath}.`:"."),{nodes:cycleIndex}))}spreadPath.pop()}spreadPathIndexByName[fragmentName]=
void 0}}}const visitedFrags=Object.create(null),spreadPath=[],spreadPathIndexByName=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(node){detectCycleRecursive(node);return!1}}};var _GraphQLError=require("module$node_modules$graphql$error$GraphQLError")}
//# sourceMappingURL=module$node_modules$graphql$validation$rules$NoFragmentCyclesRule.js.map
