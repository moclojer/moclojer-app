shadow$provide.module$node_modules$$testing_library$dom$dist$wait_for_element_to_be_removed=function(global,require,module,exports){function initialCheck(elements){if(!elements||Array.isArray(elements)&&!elements.length)throw Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");}Object.defineProperty(exports,"__esModule",{value:!0});exports.waitForElementToBeRemoved=async function(callback,
options){const timeoutError=Error("Timed out in waitForElementToBeRemoved.");if("function"!==typeof callback){initialCheck(callback);const getRemainingElements=(Array.isArray(callback)?callback:[callback]).map(element=>{let parent=element.parentElement;if(null===parent)return()=>null;for(;parent.parentElement;)parent=parent.parentElement;return()=>parent.contains(element)?element:null});callback=()=>getRemainingElements.map(c=>c()).filter(Boolean)}initialCheck(callback());return(0,_waitFor.waitFor)(()=>
{try{var result=callback()}catch(error){if("TestingLibraryElementError"===error.name)return;throw error;}if(result&&(!Array.isArray(result)||result.length))throw timeoutError;},options)};var _waitFor=require("module$node_modules$$testing_library$dom$dist$wait_for")}
//# sourceMappingURL=module$node_modules$$testing_library$dom$dist$wait_for_element_to_be_removed.js.map
