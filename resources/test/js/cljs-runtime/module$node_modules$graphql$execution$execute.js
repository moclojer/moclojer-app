shadow$provide.module$node_modules$graphql$execution$execute=function(global,require,module,exports){function execute(args){2>arguments.length||(0,_devAssert.devAssert)(!1,"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");const {schema,document,variableValues,rootValue}=args;assertValidExecutionArguments(schema,document,variableValues);const exeContext=buildExecutionContext(args);if(!("schema"in exeContext))return{errors:exeContext};try{const {operation}=
exeContext,result=executeOperation(exeContext,operation,rootValue);return(0,_isPromise.isPromise)(result)?result.then(data=>buildResponse(data,exeContext.errors),error=>{exeContext.errors.push(error);return buildResponse(null,exeContext.errors)}):buildResponse(result,exeContext.errors)}catch(error){return exeContext.errors.push(error),buildResponse(null,exeContext.errors)}}function buildResponse(data,errors){return 0===errors.length?{data}:{errors,data}}function assertValidExecutionArguments(schema,
document,rawVariableValues){document||(0,_devAssert.devAssert)(!1,"Must provide document.");(0,_validate.assertValidSchema)(schema);null==rawVariableValues||(0,_isObjectLike.isObjectLike)(rawVariableValues)||(0,_devAssert.devAssert)(!1,"Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.")}function buildExecutionContext(args){var _definition$name,_operation$variableDe;const {schema,document,rootValue,contextValue,
variableValues:rawVariableValues,operationName,fieldResolver,typeResolver,subscribeFieldResolver}=args;let operation;args=Object.create(null);for(const definition of document.definitions)switch(definition.kind){case _kinds.Kind.OPERATION_DEFINITION:if(null==operationName){if(void 0!==operation)return[new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")];operation=definition}else(null===(_definition$name=definition.name)||void 0===_definition$name?void 0:
_definition$name.value)===operationName&&(operation=definition);break;case _kinds.Kind.FRAGMENT_DEFINITION:args[definition.name.value]=definition}if(!operation)return null!=operationName?[new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)]:[new _GraphQLError.GraphQLError("Must provide an operation.")];_definition$name=null!==(_operation$variableDe=operation.variableDefinitions)&&void 0!==_operation$variableDe?_operation$variableDe:[];_operation$variableDe=(0,_values.getVariableValues)(schema,
_definition$name,null!==rawVariableValues&&void 0!==rawVariableValues?rawVariableValues:{},{maxErrors:50});return _operation$variableDe.errors?_operation$variableDe.errors:{schema,fragments:args,rootValue,contextValue,operation,variableValues:_operation$variableDe.coerced,fieldResolver:null!==fieldResolver&&void 0!==fieldResolver?fieldResolver:defaultFieldResolver,typeResolver:null!==typeResolver&&void 0!==typeResolver?typeResolver:defaultTypeResolver,subscribeFieldResolver:null!==subscribeFieldResolver&&
void 0!==subscribeFieldResolver?subscribeFieldResolver:defaultFieldResolver,errors:[]}}function executeOperation(exeContext,operation,rootValue){const rootType=exeContext.schema.getRootType(operation.operation);if(null==rootType)throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`,{nodes:operation});const rootFields=(0,_collectFields.collectFields)(exeContext.schema,exeContext.fragments,exeContext.variableValues,rootType,operation.selectionSet);
switch(operation.operation){case _ast.OperationTypeNode.QUERY:return executeFields(exeContext,rootType,rootValue,void 0,rootFields);case _ast.OperationTypeNode.MUTATION:return executeFieldsSerially(exeContext,rootType,rootValue,void 0,rootFields);case _ast.OperationTypeNode.SUBSCRIPTION:return executeFields(exeContext,rootType,rootValue,void 0,rootFields)}}function executeFieldsSerially(exeContext,parentType,sourceValue,path,fields){return(0,_promiseReduce.promiseReduce)(fields.entries(),(results,
[responseName,fieldNodes])=>{const fieldPath=(0,_Path.addPath)(path,responseName,parentType.name);fieldNodes=executeField(exeContext,parentType,sourceValue,fieldNodes,fieldPath);if(void 0===fieldNodes)return results;if((0,_isPromise.isPromise)(fieldNodes))return fieldNodes.then(resolvedResult=>{results[responseName]=resolvedResult;return results});results[responseName]=fieldNodes;return results},Object.create(null))}function executeFields(exeContext,parentType,sourceValue,path,fields){const results=
Object.create(null);let containsPromise=!1;for(const [responseName,fieldNodes]of fields.entries())fields=(0,_Path.addPath)(path,responseName,parentType.name),fields=executeField(exeContext,parentType,sourceValue,fieldNodes,fields),void 0!==fields&&(results[responseName]=fields,(0,_isPromise.isPromise)(fields)&&(containsPromise=!0));return containsPromise?(0,_promiseForObject.promiseForObject)(results):results}function executeField(exeContext,parentType,source,fieldNodes,path){var _fieldDef$resolve;
const fieldDef=getFieldDef(exeContext.schema,parentType,fieldNodes[0]);if(fieldDef){var returnType=fieldDef.type,resolveFn=null!==(_fieldDef$resolve=fieldDef.resolve)&&void 0!==_fieldDef$resolve?_fieldDef$resolve:exeContext.fieldResolver,info=buildResolveInfo(exeContext,fieldDef,fieldNodes,parentType,path);try{const args=(0,_values.getArgumentValues)(fieldDef,fieldNodes[0],exeContext.variableValues),result=resolveFn(source,args,exeContext.contextValue,info);let completed;completed=(0,_isPromise.isPromise)(result)?
result.then(resolved=>completeValue(exeContext,returnType,fieldNodes,info,path,resolved)):completeValue(exeContext,returnType,fieldNodes,info,path,result);return(0,_isPromise.isPromise)(completed)?completed.then(void 0,rawError=>{rawError=(0,_locatedError.locatedError)(rawError,fieldNodes,(0,_Path.pathToArray)(path));return handleFieldError(rawError,returnType,exeContext)}):completed}catch(rawError){return parentType=(0,_locatedError.locatedError)(rawError,fieldNodes,(0,_Path.pathToArray)(path)),
handleFieldError(parentType,returnType,exeContext)}}}function buildResolveInfo(exeContext,fieldDef,fieldNodes,parentType,path){return{fieldName:fieldDef.name,fieldNodes,returnType:fieldDef.type,parentType,path,schema:exeContext.schema,fragments:exeContext.fragments,rootValue:exeContext.rootValue,operation:exeContext.operation,variableValues:exeContext.variableValues}}function handleFieldError(error,returnType,exeContext){if((0,_definition.isNonNullType)(returnType))throw error;exeContext.errors.push(error);
return null}function completeValue(exeContext,returnType,fieldNodes,info,path,result){if(result instanceof Error)throw result;if((0,_definition.isNonNullType)(returnType)){returnType=completeValue(exeContext,returnType.ofType,fieldNodes,info,path,result);if(null===returnType)throw Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);return returnType}if(null==result)return null;if((0,_definition.isListType)(returnType))return completeListValue(exeContext,returnType,
fieldNodes,info,path,result);if((0,_definition.isLeafType)(returnType)){info=returnType.serialize(result);if(null==info)throw Error(`Expected \`${(0,_inspect.inspect)(returnType)}.serialize(${(0,_inspect.inspect)(result)})\` to `+`return non-nullable value, returned: ${(0,_inspect.inspect)(info)}`);return info}if((0,_definition.isAbstractType)(returnType))return completeAbstractValue(exeContext,returnType,fieldNodes,info,path,result);if((0,_definition.isObjectType)(returnType))return completeObjectValue(exeContext,
returnType,fieldNodes,info,path,result);(0,_invariant.invariant)(!1,"Cannot complete value of unexpected output type: "+(0,_inspect.inspect)(returnType))}function completeListValue(exeContext,returnType,fieldNodes,info,path,result){if(!(0,_isIterableObject.isIterableObject)(result))throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);const itemType=returnType.ofType;let containsPromise=!1;returnType=Array.from(result,
(item,index)=>{const itemPath=(0,_Path.addPath)(path,index,void 0);try{let completedItem;completedItem=(0,_isPromise.isPromise)(item)?item.then(resolved=>completeValue(exeContext,itemType,fieldNodes,info,itemPath,resolved)):completeValue(exeContext,itemType,fieldNodes,info,itemPath,item);return(0,_isPromise.isPromise)(completedItem)?(containsPromise=!0,completedItem.then(void 0,rawError=>{rawError=(0,_locatedError.locatedError)(rawError,fieldNodes,(0,_Path.pathToArray)(itemPath));return handleFieldError(rawError,
itemType,exeContext)})):completedItem}catch(rawError){return item=(0,_locatedError.locatedError)(rawError,fieldNodes,(0,_Path.pathToArray)(itemPath)),handleFieldError(item,itemType,exeContext)}});return containsPromise?Promise.all(returnType):returnType}function completeAbstractValue(exeContext,returnType,fieldNodes,info,path,result){var _returnType$resolveTy;const runtimeType=(null!==(_returnType$resolveTy=returnType.resolveType)&&void 0!==_returnType$resolveTy?_returnType$resolveTy:exeContext.typeResolver)(result,
exeContext.contextValue,info,returnType);return(0,_isPromise.isPromise)(runtimeType)?runtimeType.then(resolvedRuntimeType=>completeObjectValue(exeContext,ensureValidRuntimeType(resolvedRuntimeType,exeContext,returnType,fieldNodes,info,result),fieldNodes,info,path,result)):completeObjectValue(exeContext,ensureValidRuntimeType(runtimeType,exeContext,returnType,fieldNodes,info,result),fieldNodes,info,path,result)}function ensureValidRuntimeType(runtimeTypeName,exeContext,returnType,fieldNodes,info,result){if(null==
runtimeTypeName)throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,fieldNodes);if((0,_definition.isObjectType)(runtimeTypeName))throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
if("string"!==typeof runtimeTypeName)throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with `+`value ${(0,_inspect.inspect)(result)}, received "${(0,_inspect.inspect)(runtimeTypeName)}".`);info=exeContext.schema.getType(runtimeTypeName);if(null==info)throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
{nodes:fieldNodes});if(!(0,_definition.isObjectType)(info))throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,{nodes:fieldNodes});if(!exeContext.schema.isSubType(returnType,info))throw new _GraphQLError.GraphQLError(`Runtime Object type "${info.name}" is not a possible type for "${returnType.name}".`,{nodes:fieldNodes});return info}function completeObjectValue(exeContext,returnType,fieldNodes,info,path,result){const subFieldNodes=
collectSubfields(exeContext,returnType,fieldNodes);if(returnType.isTypeOf){info=returnType.isTypeOf(result,exeContext.contextValue,info);if((0,_isPromise.isPromise)(info))return info.then(resolvedIsTypeOf=>{if(!resolvedIsTypeOf)throw invalidReturnTypeError(returnType,result,fieldNodes);return executeFields(exeContext,returnType,result,path,subFieldNodes)});if(!info)throw invalidReturnTypeError(returnType,result,fieldNodes);}return executeFields(exeContext,returnType,result,path,subFieldNodes)}function invalidReturnTypeError(returnType,
result,fieldNodes){return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0,_inspect.inspect)(result)}.`,{nodes:fieldNodes})}function getFieldDef(schema,parentType,fieldNode){fieldNode=fieldNode.name.value;return fieldNode===_introspection.SchemaMetaFieldDef.name&&schema.getQueryType()===parentType?_introspection.SchemaMetaFieldDef:fieldNode===_introspection.TypeMetaFieldDef.name&&schema.getQueryType()===parentType?_introspection.TypeMetaFieldDef:fieldNode===
_introspection.TypeNameMetaFieldDef.name?_introspection.TypeNameMetaFieldDef:parentType.getFields()[fieldNode]}Object.defineProperty(exports,"__esModule",{value:!0});exports.assertValidExecutionArguments=assertValidExecutionArguments;exports.buildExecutionContext=buildExecutionContext;exports.buildResolveInfo=buildResolveInfo;exports.defaultTypeResolver=exports.defaultFieldResolver=void 0;exports.execute=execute;exports.executeSync=function(args){args=execute(args);if((0,_isPromise.isPromise)(args))throw Error("GraphQL execution failed to complete synchronously.");
return args};exports.getFieldDef=getFieldDef;var _devAssert=require("module$node_modules$graphql$jsutils$devAssert"),_inspect=require("module$node_modules$graphql$jsutils$inspect"),_invariant=require("module$node_modules$graphql$jsutils$invariant"),_isIterableObject=require("module$node_modules$graphql$jsutils$isIterableObject"),_isObjectLike=require("module$node_modules$graphql$jsutils$isObjectLike"),_isPromise=require("module$node_modules$graphql$jsutils$isPromise");global=require("module$node_modules$graphql$jsutils$memoize3");
var _Path=require("module$node_modules$graphql$jsutils$Path"),_promiseForObject=require("module$node_modules$graphql$jsutils$promiseForObject"),_promiseReduce=require("module$node_modules$graphql$jsutils$promiseReduce"),_GraphQLError=require("module$node_modules$graphql$error$GraphQLError"),_locatedError=require("module$node_modules$graphql$error$locatedError"),_ast=require("module$node_modules$graphql$language$ast"),_kinds=require("module$node_modules$graphql$language$kinds"),_definition=require("module$node_modules$graphql$type$definition"),
_introspection=require("module$node_modules$graphql$type$introspection"),_validate=require("module$node_modules$graphql$type$validate"),_collectFields=require("module$node_modules$graphql$execution$collectFields"),_values=require("module$node_modules$graphql$execution$values");const collectSubfields=(0,global.memoize3)((exeContext,returnType,fieldNodes)=>(0,_collectFields.collectSubfields)(exeContext.schema,exeContext.fragments,exeContext.variableValues,returnType,fieldNodes)),defaultTypeResolver=
function(value,contextValue,info,abstractType){if((0,_isObjectLike.isObjectLike)(value)&&"string"===typeof value.__typename)return value.__typename;const possibleTypes=info.schema.getPossibleTypes(abstractType);abstractType=[];for(let i=0;i<possibleTypes.length;i++){const type=possibleTypes[i];if(type.isTypeOf){const isTypeOfResult=type.isTypeOf(value,contextValue,info);if((0,_isPromise.isPromise)(isTypeOfResult))abstractType[i]=isTypeOfResult;else if(isTypeOfResult)return type.name}}if(abstractType.length)return Promise.all(abstractType).then(isTypeOfResults=>
{for(let i=0;i<isTypeOfResults.length;i++)if(isTypeOfResults[i])return possibleTypes[i].name})};exports.defaultTypeResolver=defaultTypeResolver;const defaultFieldResolver=function(source,args,contextValue,info){if((0,_isObjectLike.isObjectLike)(source)||"function"===typeof source){const property=source[info.fieldName];return"function"===typeof property?source[info.fieldName](args,contextValue,info):property}};exports.defaultFieldResolver=defaultFieldResolver}
//# sourceMappingURL=module$node_modules$graphql$execution$execute.js.map
