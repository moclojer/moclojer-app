{"version":3,"sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__57618","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","promesa.core/wrap","G__57624","promesa.core/create","f","d","e57627","G__57629","p1__57619#","G__57630","p1__57620#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e57631","G__57632","p1__57621#","G__57633","p1__57622#","promesa.core/promise?","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IPromise","promesa.core/deferred?","promesa.impl/*default-promise*","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","G__57650","promesa.core/then","p","promesa.protocols/-then","G__57653","promesa.core/bind","promesa.protocols/-bind","G__57661","promesa.core/then'","G__57664","promesa.core/map","G__57668","promesa.core/mapcat","G__57688","promesa.core/chain","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq57683","G__57684","cljs.core/first","cljs.core/next","G__57685","self__5754__auto__","promesa.core.then","fs","p1__57680#","p2__57681#","cljs.core.reduce","cljs.core/cons","G__57698","promesa.core/chain'","seq57694","G__57695","G__57696","promesa.core.then_SINGLEQUOTE_","G__57825","promesa.core/handle","promesa.protocols/-handle","G__57834","promesa.core/finally","promesa.protocols/-finally","G__57848","promesa.core/catch","promesa.protocols/-thenErr","pred-or-type","accept?","p1__57842#","cljs.core/ifn?","G__57874","promesa.core/catch'","promesa.protocols/-mapErr","p1__57859#","G__57889","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__57951","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__57990","cljs.core/seq","chunk__57991","count__57992","i__57993","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__58123","cljs.core/--destructure-map","cljs.core.get","map__58136","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__58125","G__58153","cljs.core.ex_info","G__58167","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/same-thread-executor","p1__58161#","p2__58162#","_","promesa.core.promise","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__58220","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e58221","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__58224","promesa.core/timeout","t","promesa.core.timeout","scheduler","timeout","tid","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","promesa.core.finally$","G__58232","promesa.core/delay","promesa.core.delay","G__58239","promesa.core/thread-call","promesa.exec.submit_BANG_","promesa.exec/wrap-bindings","promesa.core/vthread-call","promesa.core.thread_call","promesa.core/*loop-run-fn*","promesa.exec/run!"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur\n                            -> ->> as-> with-redefs do\n                            doseq])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates an appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v]\n   (pt/-promise v))\n  ([v executor]\n   (pt/-map (pt/-promise v) identity executor)))\n\n(defn wrap\n  \"A convenience alias for `promise` coercion function that only accepts\n  a single argument.\"\n  [v]\n  (pt/-promise v))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Throwable :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (satisfies? pt/IPromise v))\n\n  ;; #?(:clj (instance? CompletionStage v)\n  ;;    :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`).\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n#?(:clj\n   (defn resolved?\n     \"Returns true if promise `p` is already fulfilled.\"\n     [p]\n     (pt/-resolved? p)))\n\n#?(:clj\n   (defn rejected?\n     \"Returns true if promise `p` is already rejected.\"\n     [p]\n     (pt/-rejected? p)))\n\n#?(:clj\n   (defn pending?\n     \"Returns true if promise `p` is stil pending.\"\n     [p]\n     (pt/-pending? p)))\n\n#?(:clj\n   (defn extract\n     \"Returns the current promise value.\"\n     [p]\n     (pt/-extract p)))\n\n#?(:clj\n   (def done?\n     \"Returns true if promise `p` is already done.\"\n     (complement pending?)))\n\n;; Chaining\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-then (pt/-promise p) f))\n  ([p f executor]\n   (pt/-then (pt/-promise p) f executor)))\n\n(defn bind\n  ([p f]\n   (pt/-bind (pt/-promise p) f))\n  ([p f executor]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f]\n   (pt/-map (pt/-promise p) f))\n  ([p f executor]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then`, this does not perform automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-map (pt/-promise p) f))\n  ([executor f p]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. `f` must return a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-bind (pt/-promise p) f))\n  ([executor f p]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flatten the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map (pt/-promise p) (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f]\n   (pt/-handle (pt/-promise p) f))\n  ([p f executor]\n   (pt/-handle (pt/-promise p) f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f]\n   (pt/-finally (pt/-promise p) f))\n  ([p f executor]\n   (pt/-finally (pt/-promise p) f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-thenErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-thenErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn catch'\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-mapErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-mapErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (c/-> (.all impl/*default-promise* (into-array promises))\n                 (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (c/->> (into-array CompletableFuture promises)\n                          (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (c/->> (clojure.core/map pt/-promise promises)\n                                          (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                        :counter (count promises)\n                        :rejections []})]\n     (create\n      (fn [resolve reject]\n        (c/doseq [p promises]\n          (c/-> (pt/-promise p)\n                (then (fn [v]\n                        (when-not (:resolved @state)\n                          (swap! state (fn [state]\n                                         (c/-> state\n                                               (assoc :resolved true)\n                                               (update :counter dec))))\n                          (resolve v))))\n                (catch (fn [e]\n                         (swap! state (fn [state]\n                                        (c/-> state\n                                              (update  :counter dec)\n                                              (update :rejections conj e))))\n                         (c/let [{:keys [resolved counter rejections]} @state]\n                           (when (and (not resolved) (= counter 0))\n                             (if (= default ::default)\n                               (reject (ex-info \"No promises resolved\"\n                                                {:rejections rejections}))\n                               (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/same-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument, return a\n  function that returns a promise. Callback is expected to take one\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (c/-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError.\"\n  ([p t] (timeout p t ::default :default))\n  ([p t v] (timeout p t v :default))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)\n           tid     (exec/schedule! scheduler t #(if (= v ::default)\n                                                  (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                                  (resolve! timeout v)))]\n     (race [(finally p (fn [_ _] (pt/-cancel! tid))) timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will be fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil :default))\n  ([t v] (delay t v :default))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do!\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression after awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(condp = (count exprs)\n         0 `(pt/-promise nil)\n         1 `(pt/-promise ~(first exprs))\n         (reduce (fn [acc e]\n                   `(pt/-bind (pt/-promise ~e) (fn [_#] ~acc)))\n                 `(pt/-promise ~(last exprs))\n                 (reverse (butlast exprs)))))))\n\n\n(defmacro do\n  \"An alias for do!\"\n  [& exprs]\n  `(do! ~@exprs))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/->> (reverse (partition 2 bindings))\n              (reduce (fn [acc [l r]]\n                        `(pt/-bind (pt/-promise ~r) (fn [~l] ~acc)))\n                      `(do! ~@body))))))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/let [bindings (partition 2 bindings)]\n         `(c/-> (all ~(mapv second bindings))\n                (then (fn [[~@(mapv first bindings)]]\n                        (do! ~@body))))))))\n\n(defn thread-call\n  \"Analogous to `clojure.core.async/thread` that returns a promise\n  instance instead of the `Future`. Useful for executing synchronous\n  code in a separate thread (also works in cljs).\"\n  ([f] (exec/submit! :thread (exec/wrap-bindings f)))\n  ([executor f] (exec/submit! executor (exec/wrap-bindings f))))\n\n(defn vthread-call\n  \"A shortcut for `(p/thread-call :vthread f)`.\"\n  [f]\n  (thread-call :vthread f))\n\n(defmacro thread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`.\"\n  [& body]\n  `(thread-call (^once fn [] ~@body)))\n\n(defmacro vthread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`. Useful for executing synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(vthread-call (^once fn [] ~@body)))\n\n(defmacro future\n  \"Analogous macro to `clojure.core/future` that returns promise\n  instance instead of the `Future`. Exposed just for convenience and\n  works as an alias to `thread`.\"\n  [& body]\n  `(thread-call :default (^once fn [] ~@body)))\n\n(def ^:dynamic *loop-run-fn* exec/run!)\n\n(defmacro loop\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          tsym (gensym \"loop\")\n          dsym (gensym \"deferred\")\n          rsym (gensym \"run\")]\n    `(c/let [~rsym *loop-run-fn*\n             ~dsym (promesa.core/deferred)\n             ~tsym (fn ~tsym [params#]\n                     (c/-> (promesa.core/all params#)\n                           (promesa.core/then (fn [[~@names]]\n                                                ;; (prn \"exec\" ~@names)\n                                                (do! ~@body)))\n                           (promesa.core/handle\n                            (fn [res# err#]\n                              ;; (prn \"result\" res# err#)\n                              (cond\n                                (not (nil? err#))\n                                (promesa.core/reject! ~dsym err#)\n\n                                (and (map? res#) (= (:type res#) :promesa.core/recur))\n                                (do (~rsym (fn [] (~tsym (:args res#))))\n                                    nil)\n\n                                :else\n                                (promesa.core/resolve! ~dsym res#))))))]\n       (~rsym (fn [] (~tsym ~fvals)))\n       ~dsym)))\n\n(defmacro recur\n  [& args]\n  `(array-map :type :promesa.core/recur :args [~@args]))\n\n(defmacro ->\n  \"Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f p# ~@args)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro ->>\n  \"Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f ~@args p#)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro as->\n  \"Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))\n\n(defmacro with-redefs\n  \"Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.\"\n  [bindings & body]\n  (c/let [names         (take-nth 2 bindings)\n          vals          (take-nth 2 (drop 1 bindings))\n          orig-val-syms (c/map (comp gensym #(str % \"-orig-val__\") name) names)\n          temp-val-syms (c/map (comp gensym #(str % \"-temp-val__\") name) names)\n          binds         (c/map vector names temp-val-syms)\n          resets        (reverse (c/map vector names orig-val-syms))\n          bind-value    (if (:ns &env)\n                          (fn [[k v]] (list 'set! k v))\n                          (fn [[k v]] (list 'alter-var-root (list 'var k) (list 'constantly v))))]\n    `(c/let [~@(interleave orig-val-syms names)\n             ~@(interleave temp-val-syms vals)]\n       ~@(c/map bind-value binds)\n       (c/-> (promesa.core/do! ~@body)\n             (promesa.core/finally\n               (fn [_# _#]\n                 ~@(c/map bind-value resets)))))))\n\n(defmacro doseq\n  \"Simplified version of `doseq` which takes one binding and a seq, and\n  runs over it using `promesa.core/run!`\"\n  [[binding xs] & body]\n  `(run! (fn [~binding]\n             (promesa.core/do ~@body))\n           ~xs))\n"]}