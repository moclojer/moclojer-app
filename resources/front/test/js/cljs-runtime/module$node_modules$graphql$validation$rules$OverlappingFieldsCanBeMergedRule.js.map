{
"version":3,
"file":"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMergedRule.js",
"lineCount":21,
"mappings":"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",
"sources":["node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMergedRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _sortValueNode = require('../../utilities/sortValueNode.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nfunction OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      (0, _definition.isObjectType)(parentType1) &&\n      (0, _definition.isObjectType)(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${(0, _inspect.inspect)(\n          type1,\n        )}\" and \"${(0, _inspect.inspect)(type2)}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      (0, _definition.getNamedType)(type1),\n      selectionSet1,\n      (0, _definition.getNamedType)(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: _kinds.Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return (0, _printer.print)(\n    (0, _sortValueNode.sortValueNode)(inputObjectWithArgs),\n  );\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n\n  if (\n    (0, _definition.isLeafType)(type1) ||\n    (0, _definition.isLeafType)(type2)\n  ) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = (0, _typeFromAST.typeFromAST)(\n    context.getSchema(),\n    fragment.typeCondition,\n  );\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (\n          (0, _definition.isObjectType)(parentType) ||\n          (0, _definition.isInterfaceType)(parentType)\n        ) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","reasonMessage","reason","Array","isArray","map","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","context","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragmentName","fragment","getFragment","fieldMap2","referencedFragmentNames","getReferencedFieldsAndFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","parentFieldsAreMutuallyExclusive","fields1","Object","entries","fields2","field1","field2","conflict","findConflict","push","parentType1","node1","def1","parentType2","node2","def2","_definition","isObjectType","name1","name","value","name2","stringifyArguments","type1","type","type2","doTypesConflict","_inspect","inspect","selectionSet1","selectionSet","selectionSet2","getNamedType","fragmentNames1","getFieldsAndFragmentNames","fragmentNames2","subfieldConflicts","fieldNode","_fieldNode$arguments","args","arguments","inputObjectWithArgs","kind","_kinds","Kind","OBJECT","fields","argNode","OBJECT_FIELD","_printer","print","_sortValueNode","sortValueNode","isListType","ofType","isNonNullType","isLeafType","parentType","cached","get","nodeAndDefs","create","fragmentNames","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","_typeFromAST","typeFromAST","getSchema","typeCondition","selection","selections","FIELD","fieldName","fieldDef","isInterfaceType","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","length","flat","defineProperty","OverlappingFieldsCanBeMergedRule","PairSet","Map","SelectionSet","getParentType","i","j","reasonMsg","reportError","_GraphQLError","GraphQLError","nodes","concat","constructor","_data","a","b","_this$_data$get","key1","key2","undefined"]
}
