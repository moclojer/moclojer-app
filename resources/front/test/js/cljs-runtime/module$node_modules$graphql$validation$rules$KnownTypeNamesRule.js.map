{
"version":3,
"file":"module$node_modules$graphql$validation$rules$KnownTypeNamesRule.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,kBAAR,CAsBAA,QAA2B,CAACC,OAAD,CAAU,CACnC,MAAMC,OAASD,OAAQE,CAAAA,SAAR,EAAf,CACMC,iBAAmBF,MAAA,CAASA,MAAOG,CAAAA,UAAP,EAAT,CAA+BR,MAAOS,CAAAA,MAAP,CAAc,IAAd,CADxD,CAEMC,aAAeV,MAAOS,CAAAA,MAAP,CAAc,IAAd,CAErB,KAAK,MAAME,GAAX,GAAkBP,QAAQQ,CAAAA,WAAR,EAAsBC,CAAAA,WAAxC,CACM,GAAIC,WAAYC,CAAAA,oBAAhB,EAAsCJ,GAAtC,CAAJ,GACED,YAAA,CAAaC,GAAIK,CAAAA,IAAKd,CAAAA,KAAtB,CADF,CACiC,CAAA,CADjC,CAKF,OAAMe,UAAY,CAChB,GAAGjB,MAAOkB,CAAAA,IAAP,CAAYX,gBAAZ,CADa;AAEhB,GAAGP,MAAOkB,CAAAA,IAAP,CAAYR,YAAZ,CAFa,CAIlB,OAAO,CACLS,SAAS,CAACC,IAAD,CAAOC,EAAP,CAAWC,MAAX,CAAmBC,EAAnB,CAAuBC,SAAvB,CAAkC,CACnCC,EAAAA,CAAWL,IAAKJ,CAAAA,IAAKd,CAAAA,KAE3B,IAAI,CAACK,gBAAA,CAAiBkB,EAAjB,CAAL,EAAmC,CAACf,YAAA,CAAae,EAAb,CAApC,CAA4D,CAC1D,IAAIC,WAEEC,UAAAA,CAC6B,IAAjC,IAACD,WAAD,CAAeF,SAAA,CAAU,CAAV,CAAf,GAAyD,IAAK,EAA9D,GAAyCE,WAAzC,CACIA,WADJ,CAEIJ,MACQ,IAAA,MAAA,CAAA,IAAA,EAAA,SAAA,CAA0B,MA8B9C,CA9B8C,SA8B9C,CAAA,MAAA,CACE,MADF,EACYpB,OADZ,GAEG,GAAIY,WAAYc,CAAAA,0BAAhB,EAA4C1B,MAA5C,CAFH,EAGI,GAAIY,WAAYe,CAAAA,yBAAhB,EAA2C3B,MAA3C,CAHJ,CA5BU4B,OAAJ,EAAaC,iBAAkBC,CAAAA,QAAlB,CAA2BP,EAA3B,CAAb,GAIMQ,MAIN,CAJuB,GAAIC,eAAgBC,CAAAA,cAApB,EACrBV,EADqB,CAErBK,MAAA;AAAQC,iBAAkBK,CAAAA,MAAlB,CAAyBnB,SAAzB,CAAR,CAA8CA,SAFzB,CAIvB,CAAAb,OAAQiC,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,iBAAgBd,EAAhB,IADH,CAEI,GAAIe,WAAYC,CAAAA,UAAhB,EAA4BR,MAA5B,CAFJ,CAGE,CACES,MAAOtB,IADT,CAHF,CADF,CARA,CAT0D,CAHnB,CADtC,CAf4B,CApBrC,KAAIoB,YAAc3C,OAAA,CAAQ,gDAAR,CAAlB,CAEIqC,gBAAkBrC,OAAA,CAAQ,oDAAR,CAFtB,CAIIyC,cAAgBzC,OAAA,CAAQ,gDAAR,CAJpB,CAMIiB,YAAcjB,OAAA,CAAQ,iDAAR,CAEd8C,OAAAA,CAAiB9C,OAAA,CAAQ,gDAAR,CA8DrB;MAAMkC,kBAAoB,CACxB,GA7DalC,OAAA+C,CAAQ,0CAARA,CA6DDC,CAAAA,oBADY,CAExB,GAAGF,MAAeG,CAAAA,kBAFM,CAGxBC,CAAAA,GAHwB,CAGnBC,IAAD,EAAUA,IAAKhC,CAAAA,IAHK,CA9EkG;",
"sources":["node_modules/graphql/validation/rules/KnownTypeNamesRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$KnownTypeNamesRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _introspection = require('../../type/introspection.js');\n\nvar _scalars = require('../../type/scalars.js');\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nfunction KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = (0, _suggestionList.suggestionList)(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Unknown type \"${typeName}\".` +\n              (0, _didYouMean.didYouMean)(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nconst standardTypeNames = [\n  ..._scalars.specifiedScalarTypes,\n  ..._introspection.introspectionTypes,\n].map((type) => type.name);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    ((0, _predicates.isTypeSystemDefinitionNode)(value) ||\n      (0, _predicates.isTypeSystemExtensionNode)(value))\n  );\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","KnownTypeNamesRule","context","schema","getSchema","existingTypesMap","getTypeMap","create","definedTypes","def","getDocument","definitions","_predicates","isTypeDefinitionNode","name","typeNames","keys","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","isSDL","standardTypeNames","includes","suggestedTypes","_suggestionList","suggestionList","concat","reportError","_GraphQLError","GraphQLError","_didYouMean","didYouMean","nodes","_introspection","_scalars","specifiedScalarTypes","introspectionTypes","map","type"]
}
