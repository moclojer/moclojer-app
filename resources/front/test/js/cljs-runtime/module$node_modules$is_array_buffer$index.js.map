{
"version":3,
"file":"module$node_modules$is_array_buffer$index.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,yCAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGlGC,MAAAA,CAAWH,OAAA,CAAQ,qCAAR,CACXI,QAAAA,CAAYJ,OAAA,CAAQ,yCAAR,CAChB,KAAIK,aAAeL,OAAA,CAAQ,yCAAR,CAAnB,CACIM,aAAeN,OAAA,CAAQ,0CAAR,CAEfO,QAAAA,CAAeF,YAAA,CAAa,aAAb,CAA4B,CAAA,CAA5B,CACnB,KAAIG,cAAgBH,YAAA,CAAa,cAAb,CAA6B,CAAA,CAA7B,CAApB,CACII,YAAcL,OAAA,CAAU,kCAAV,CAA8C,CAAA,CAA9C,CADlB,CAKIM,UADAC,OACAD;AADUH,OACVG,EAD0B,CAACD,WAC3BC,EAD6DE,CAAnB,IAAIL,OAAeK,EAAAA,KAC7DF,GAAsBP,MAAA,CAASQ,OAAT,CAE1BV,OAAOC,CAAAA,OAAP,CAAiBO,WAAA,EAAeC,QAAf,CACdG,QAAsB,CAACC,GAAD,CAAM,CAC7B,GAAI,CAACA,GAAL,EAA2B,QAA3B,GAAY,MAAOA,IAAnB,CACC,MAAO,CAAA,CAER,IAAI,CAMH,MALIL,YAAJ,CACCA,WAAA,CAAYK,GAAZ,CADD,CAGCJ,QAAA,CAASI,GAAT,CAAc,CAAd,CAEM,CAAA,CAAA,CANJ,CAOF,MAAOC,CAAP,CAAU,CACX,MAAO,CAAA,CADI,CAXiB,CADd,CAgBdP,aAAA,CAECQ,QAAsB,CAACF,GAAD,CAAM,CAC7B,GAAI,CACH,MAAgCG,CAAxB,IAAIT,aAAJ,CAAkBM,GAAlB,CAAwBG,EAAAA,MAAhC,GAA2CH,GAA3C,EAAkD,CAACR,YAAA,CAAaQ,GAAb,CADhD,CAEF,MAAOC,CAAP,CAAU,CACX,MAAsB,QAAtB,GAAO,MAAOD,IAAd,EAA6C,YAA7C,GAAkCC,CAAEG,CAAAA,IADzB,CAHiB,CAF7B,CASCL,QAAsB,CAACC,GAAD,CAAM,CAC7B,MAAO,CAAA,CADsB,CAzCsE;",
"sources":["node_modules/is-array-buffer/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$is_array_buffer$index\"] = function(global,require,module,exports) {\n'use strict';\n\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar GetIntrinsic = require('get-intrinsic');\nvar isTypedArray = require('is-typed-array');\n\nvar $ArrayBuffer = GetIntrinsic('ArrayBuffer', true);\nvar $Float32Array = GetIntrinsic('Float32Array', true);\nvar $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);\n\n// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method\nvar abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;\nvar $abSlice = abSlice && callBind(abSlice);\n\nmodule.exports = $byteLength || $abSlice\n\t? function isArrayBuffer(obj) {\n\t\tif (!obj || typeof obj !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tif ($byteLength) {\n\t\t\t\t$byteLength(obj);\n\t\t\t} else {\n\t\t\t\t$abSlice(obj, 0);\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t: $Float32Array\n\t\t// in node 0.8, ArrayBuffers have no prototype or own methods\n\t\t? function IsArrayBuffer(obj) {\n\t\t\ttry {\n\t\t\t\treturn (new $Float32Array(obj)).buffer === obj && !isTypedArray(obj);\n\t\t\t} catch (e) {\n\t\t\t\treturn typeof obj === 'object' && e.name === 'RangeError';\n\t\t\t}\n\t\t}\n\t\t: function isArrayBuffer(obj) { // eslint-disable-line no-unused-vars\n\t\t\treturn false;\n\t\t};\n\n};"],
"names":["shadow$provide","global","require","module","exports","callBind","callBound","GetIntrinsic","isTypedArray","$ArrayBuffer","$Float32Array","$byteLength","$abSlice","abSlice","slice","isArrayBuffer","obj","e","IsArrayBuffer","buffer","name"]
}
