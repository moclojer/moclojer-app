{
"version":3,
"file":"module$node_modules$graphql$type$schema.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/graphql/type/schema.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$type$schema\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.GraphQLSchema = void 0;\nexports.assertSchema = assertSchema;\nexports.isSchema = isSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nfunction isSchema(schema) {\n  return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);\n}\n\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`,\n    );\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nclass GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    (0, _isObjectLike.isObjectLike)(config) ||\n      (0, _devAssert.devAssert)(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `\"types\" must be Array if provided but got: ${(0, _inspect.inspect)(\n          config.types,\n        )}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      (0, _devAssert.devAssert)(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${(0, _inspect.inspect)(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if ((0, _directives.isDirective)(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        (0, _devAssert.devAssert)(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if ((0, _definition.isInterfaceType)(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if ((0, _definition.isObjectType)(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case _ast.OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case _ast.OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case _ast.OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return (0, _definition.isUnionType)(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if ((0, _definition.isUnionType)(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nexports.GraphQLSchema = GraphQLSchema;\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = (0, _definition.getNamedType)(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if ((0, _definition.isUnionType)(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (\n      (0, _definition.isObjectType)(namedType) ||\n      (0, _definition.isInterfaceType)(namedType)\n    ) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if ((0, _definition.isInputObjectType)(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","isSchema","schema","_instanceOf","instanceOf","GraphQLSchema","collectReferencedTypes","type","typeSet","namedType","_definition","getNamedType","has","add","isUnionType","memberType","getTypes","isObjectType","isInterfaceType","interfaceType","getInterfaces","field","Object","values","getFields","arg","args","isInputObjectType","defineProperty","value","assertSchema","Error","_inspect","inspect","_devAssert","_isObjectLike","_toObjMap","_ast","_directives","_introspection","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","isObjectLike","devAssert","types","Array","isArray","directives","description","extensions","toObjMap","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","specifiedDirectives","allReferencedTypes","Set","delete","directive","isDirective","__Schema","_typeMap","create","_subTypeMap","_implementationsMap","typeName","name","iface","implementations","objects","interfaces","push","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","OperationTypeNode","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","getImplementations","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig"]
}
