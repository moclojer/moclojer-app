{
"version":3,
"file":"module$node_modules$graphql$execution$collectFields.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/graphql/execution/collectFields.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$execution$collectFields\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.collectFields = collectFields;\nexports.collectSubfields = collectSubfields;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _values = require('./values.js');\n\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\nfunction collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nfunction collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case _kinds.Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, _values.getDirectiveValues)(\n    _directives.GraphQLSkipDirective,\n    node,\n    variableValues,\n  );\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = (0, _values.getDirectiveValues)(\n    _directives.GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = (0, _typeFromAST.typeFromAST)(\n    schema,\n    typeConditionNode,\n  );\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","collectFieldsImpl","schema","fragments","variableValues","runtimeType","selectionSet","fields","visitedFragmentNames","selection","selections","kind","_kinds","Kind","FIELD","shouldIncludeNode","name","alias","value","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","has","add","fragment","node","skip","_values","getDirectiveValues","_directives","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","type","typeConditionNode","typeCondition","conditionalType","_typeFromAST","typeFromAST","_definition","isAbstractType","isSubType","Object","defineProperty","collectFields","Map","Set","collectSubfields","returnType","fieldNodes","subFieldNodes"]
}
