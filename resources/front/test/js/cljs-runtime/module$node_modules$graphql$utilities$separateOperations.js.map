{
"version":3,
"file":"module$node_modules$graphql$utilities$separateOperations.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAmErHC,QAASA,8BAA6B,CAACC,SAAD,CAAYC,QAAZ,CAAsBC,QAAtB,CAAgC,CACpE,GAAI,CAACF,SAAUG,CAAAA,GAAV,CAAcD,QAAd,CAAL,GACEF,SAAUI,CAAAA,GAAV,CAAcF,QAAd,CAGI,CAFEG,QAEF,CAFkBJ,QAAA,CAASC,QAAT,CAElB,CAAkBI,IAAAA,EAAlB,GAAAD,QAJN,EAKI,IAAK,MAAME,MAAX,GAAqBF,SAArB,CACEN,6BAAA,CAA8BC,SAA9B,CAAyCC,QAAzC,CAAmDM,MAAnD,CAP8D,CAatEC,QAASA,oBAAmB,CAACC,YAAD,CAAe,CACzC,MAAMC,aAAe,EACrB,IAAIC,QAASC,CAAAA,KAAb,EAAoBH,YAApB,CAAkC,CAChCI,cAAc,CAACC,IAAD,CAAO,CACnBJ,YAAaK,CAAAA,IAAb,CAAkBD,IAAKE,CAAAA,IAAKC,CAAAA,KAA5B,CADmB,CADW,CAAlC,CAKA;MAAOP,aAPkC,CA7E3CQ,MAAOC,CAAAA,cAAP,CAAsBrB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CmB,MAAO,CAAA,CADoC,CAA7C,CAGAnB,QAAQsB,CAAAA,kBAAR,CAYAA,QAA2B,CAACC,WAAD,CAAc,CACvC,MAAMC,WAAa,EAAnB,CACMrB,SAAWiB,MAAOK,CAAAA,MAAP,CAAc,IAAd,CAEjB,KAAK,IAAMC,cAAX,GAA6BH,YAAYI,CAAAA,WAAzC,CACE,OAAQD,cAAeE,CAAAA,IAAvB,EACE,KAAKC,MAAOC,CAAAA,IAAKC,CAAAA,oBAAjB,CACEP,UAAWP,CAAAA,IAAX,CAAgBS,cAAhB,CACA,MAEF,MAAKG,MAAOC,CAAAA,IAAKE,CAAAA,mBAAjB,CACE7B,QAAA,CAASuB,cAAeR,CAAAA,IAAKC,CAAAA,KAA7B,CAAA,CAAsCT,mBAAA,CACpCgB,cAAef,CAAAA,YADqB,CAN1C,CAgBIsB,cAAAA,CAAwBb,MAAOK,CAAAA,MAAP,CAAc,IAAd,CAE9B,KAAK,MAAMS,SAAX,GAAwBV,WAAxB,CAAoC,CAClC,MAAMZ;AAAe,IAAIuB,GAEzB,KAAK,MAAMC,YAAX,GAA2B1B,oBAAA,CAAoBwB,SAAUvB,CAAAA,YAA9B,CAA3B,CACEV,6BAAA,CAA8BW,YAA9B,CAA4CT,QAA5C,CAAsDiC,YAAtD,CAMFH,eAAA,CAHsBC,SAAUhB,CAAAA,IAAVmB,CAAiBH,SAAUhB,CAAAA,IAAKC,CAAAA,KAAhCkB,CAAwC,EAG9D,CAAA,CAAuC,CACrCT,KAAMC,MAAOC,CAAAA,IAAKQ,CAAAA,QADmB,CAErCX,YAAaJ,WAAYI,CAAAA,WAAYY,CAAAA,MAAxB,CACVvB,IAAD,EACEA,IADF,GACWkB,SADX,EAEGlB,IAAKY,CAAAA,IAFR,GAEiBC,MAAOC,CAAAA,IAAKE,CAAAA,mBAF7B,EAGIpB,YAAaP,CAAAA,GAAb,CAAiBW,IAAKE,CAAAA,IAAKC,CAAAA,KAA3B,CAJO,CAFwB,CAVL,CAqBpC,MAAOc,eA5CgC,CAVzC,KAAIJ,OAAS/B,OAAA,CAAQ,4CAAR,CAAb,CAEIe,SAAWf,OAAA,CAAQ,8CAAR,CAVsG;",
"sources":["node_modules/graphql/utilities/separateOperations.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$utilities$separateOperations\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.separateOperations = separateOperations;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === _kinds.Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  (0, _visitor.visit)(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","collectTransitiveDependencies","collected","depGraph","fromName","has","add","immediateDeps","undefined","toName","collectDependencies","selectionSet","dependencies","_visitor","visit","FragmentSpread","node","push","name","value","Object","defineProperty","separateOperations","documentAST","operations","create","definitionNode","definitions","kind","_kinds","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","separatedDocumentASTs","operation","Set","fragmentName","operationName","DOCUMENT","filter"]
}
