shadow$provide.module$node_modules$graphql$execution$values=function(global,require,module,exports){function coerceVariableValues(schema,varDefNodes,inputs,onError){const coercedValues={};for(const varDefNode of varDefNodes){const varName=varDefNode.variable.name.value;varDefNodes=(0,_typeFromAST.typeFromAST)(schema,varDefNode.type);if(!(0,_definition.isInputType)(varDefNodes)){varDefNodes=(0,_printer.print)(varDefNode.type);onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varDefNodes}" which cannot be used as an input type.`,
{nodes:varDefNode.type}));continue}if(!Object.prototype.hasOwnProperty.call(inputs,varName)){varDefNode.defaultValue?coercedValues[varName]=(0,_valueFromAST.valueFromAST)(varDefNode.defaultValue,varDefNodes):(0,_definition.isNonNullType)(varDefNodes)&&(varDefNodes=(0,_inspect.inspect)(varDefNodes),onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varDefNodes}" was not provided.`,{nodes:varDefNode})));continue}const value=inputs[varName];null===value&&(0,_definition.isNonNullType)(varDefNodes)?
(varDefNodes=(0,_inspect.inspect)(varDefNodes),onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varDefNodes}" must not be null.`,{nodes:varDefNode}))):coercedValues[varName]=(0,_coerceInputValue.coerceInputValue)(value,varDefNodes,(path,invalidValue,error)=>{invalidValue=`Variable "$${varName}" got invalid value `+(0,_inspect.inspect)(invalidValue);0<path.length&&(invalidValue+=` at "${varName}${(0,_printPathArray.printPathArray)(path)}"`);onError(new _GraphQLError.GraphQLError(invalidValue+
"; "+error.message,{nodes:varDefNode,originalError:error.originalError}))})}return coercedValues}function getArgumentValues(def,node,variableValues){var _node$arguments;const coercedValues={};var argumentNodes=null!==(_node$arguments=node.arguments)&&void 0!==_node$arguments?_node$arguments:[];_node$arguments=(0,_keyMap.keyMap)(argumentNodes,arg=>arg.name.value);for(const argDef of def.args){def=argDef.name;argumentNodes=argDef.type;var argumentNode=_node$arguments[def];if(argumentNode){argumentNode=
argumentNode.value;var isNull=argumentNode.kind===_kinds.Kind.NULL;if(argumentNode.kind===_kinds.Kind.VARIABLE){isNull=argumentNode.name.value;if(null==variableValues||!Object.prototype.hasOwnProperty.call(variableValues,isNull)){if(void 0!==argDef.defaultValue)coercedValues[def]=argDef.defaultValue;else if((0,_definition.isNonNullType)(argumentNodes))throw new _GraphQLError.GraphQLError(`Argument "${def}" of required type "${(0,_inspect.inspect)(argumentNodes)}" `+`was provided the variable "$${isNull}" which was not provided a runtime value.`,
{nodes:argumentNode});continue}isNull=null==variableValues[isNull]}if(isNull&&(0,_definition.isNonNullType)(argumentNodes))throw new _GraphQLError.GraphQLError(`Argument "${def}" of non-null type "${(0,_inspect.inspect)(argumentNodes)}" `+"must not be null.",{nodes:argumentNode});argumentNodes=(0,_valueFromAST.valueFromAST)(argumentNode,argumentNodes,variableValues);if(void 0===argumentNodes)throw new _GraphQLError.GraphQLError(`Argument "${def}" has invalid value ${(0,_printer.print)(argumentNode)}.`,
{nodes:argumentNode});coercedValues[def]=argumentNodes}else if(void 0!==argDef.defaultValue)coercedValues[def]=argDef.defaultValue;else if((0,_definition.isNonNullType)(argumentNodes))throw new _GraphQLError.GraphQLError(`Argument "${def}" of required type "${(0,_inspect.inspect)(argumentNodes)}" `+"was not provided.",{nodes:node});}return coercedValues}Object.defineProperty(exports,"__esModule",{value:!0});exports.getArgumentValues=getArgumentValues;exports.getDirectiveValues=function(directiveDef,
node,variableValues){var _node$directives;if(node=null===(_node$directives=node.directives)||void 0===_node$directives?void 0:_node$directives.find(directive=>directive.name.value===directiveDef.name))return getArgumentValues(directiveDef,node,variableValues)};exports.getVariableValues=function(schema,varDefNodes,inputs,options){const errors=[],maxErrors=null===options||void 0===options?void 0:options.maxErrors;try{const coerced=coerceVariableValues(schema,varDefNodes,inputs,error=>{if(null!=maxErrors&&
errors.length>=maxErrors)throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");errors.push(error)});if(0===errors.length)return{coerced}}catch(error){errors.push(error)}return{errors}};var _inspect=require("module$node_modules$graphql$jsutils$inspect"),_keyMap=require("module$node_modules$graphql$jsutils$keyMap"),_printPathArray=require("module$node_modules$graphql$jsutils$printPathArray"),_GraphQLError=require("module$node_modules$graphql$error$GraphQLError"),
_kinds=require("module$node_modules$graphql$language$kinds"),_printer=require("module$node_modules$graphql$language$printer"),_definition=require("module$node_modules$graphql$type$definition"),_coerceInputValue=require("module$node_modules$graphql$utilities$coerceInputValue"),_typeFromAST=require("module$node_modules$graphql$utilities$typeFromAST"),_valueFromAST=require("module$node_modules$graphql$utilities$valueFromAST")}
//# sourceMappingURL=module$node_modules$graphql$execution$values.js.map
