shadow$provide.module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMergedRule=function(global,require,module,exports){function reasonMessage(reason){return Array.isArray(reason)?reason.map(([responseName,subReason])=>`subfields "${responseName}" conflict because `+reasonMessage(subReason)).join(" and "):reason}function collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fragmentName){const fragment=
context.getFragment(fragmentName);if(fragment){var [fieldMap2,referencedFragmentNames]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment);if(fieldMap!==fieldMap2){collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fieldMap2);for(const referencedFragmentName of referencedFragmentNames)comparedFragmentPairs.has(referencedFragmentName,fragmentName,areMutuallyExclusive)||(comparedFragmentPairs.add(referencedFragmentName,
fragmentName,areMutuallyExclusive),collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,referencedFragmentName))}}}function collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,fragmentName2){if(fragmentName1!==fragmentName2&&!comparedFragmentPairs.has(fragmentName1,fragmentName2,areMutuallyExclusive)){comparedFragmentPairs.add(fragmentName1,
fragmentName2,areMutuallyExclusive);var fragment1=context.getFragment(fragmentName1),fragment2=context.getFragment(fragmentName2);if(fragment1&&fragment2){var [fieldMap1,referencedFragmentNames1]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment1),[fieldMap2,referencedFragmentNames2]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment2);collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,
fieldMap1,fieldMap2);for(const referencedFragmentName2 of referencedFragmentNames2)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,referencedFragmentName2);for(const referencedFragmentName1 of referencedFragmentNames1)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,referencedFragmentName1,fragmentName2)}}}function collectConflictsBetween(context,
conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap1,fieldMap2){for(const [responseName,fields1]of Object.entries(fieldMap1))if(fieldMap1=fieldMap2[responseName])for(const field1 of fields1)for(const field2 of fieldMap1){const conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,field1,field2);conflict&&conflicts.push(conflict)}}function findConflict(context,cachedFieldsAndFragmentNames,
comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,field1,field2){const [parentType1,node1,def1]=field1,[parentType2,node2,def2]=field2;parentFieldsAreMutuallyExclusive=parentFieldsAreMutuallyExclusive||parentType1!==parentType2&&(0,_definition.isObjectType)(parentType1)&&(0,_definition.isObjectType)(parentType2);if(!parentFieldsAreMutuallyExclusive){field1=node1.name.value;field2=node2.name.value;if(field1!==field2)return[[responseName,`"${field1}" and "${field2}" are different fields`],
[node1],[node2]];if(stringifyArguments(node1)!==stringifyArguments(node2))return[[responseName,"they have differing arguments"],[node1],[node2]]}var type1=null===def1||void 0===def1?void 0:def1.type,type2=null===def2||void 0===def2?void 0:def2.type;if(type1&&type2&&doTypesConflict(type1,type2))return[[responseName,`they return conflicting types "${(0,_inspect.inspect)(type1)}" and "${(0,_inspect.inspect)(type2)}"`],[node1],[node2]];field1=node1.selectionSet;field2=node2.selectionSet;if(field1&&field2){type1=
(0,_definition.getNamedType)(type1);type2=(0,_definition.getNamedType)(type2);const conflicts=[],[fieldMap1,fragmentNames1]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,type1,field1),[fieldMap2,fragmentNames2]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,type2,field2);collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap1,fieldMap2);for(const fragmentName2 of fragmentNames2)collectConflictsBetweenFieldsAndFragment(context,
conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap1,fragmentName2);for(const fragmentName1 of fragmentNames1)collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap2,fragmentName1);for(const fragmentName1 of fragmentNames1)for(const fragmentName2 of fragmentNames2)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,
parentFieldsAreMutuallyExclusive,fragmentName1,fragmentName2);return subfieldConflicts(conflicts,responseName,node1,node2)}}function stringifyArguments(fieldNode){var _fieldNode$arguments;fieldNode=null!==(_fieldNode$arguments=fieldNode.arguments)&&void 0!==_fieldNode$arguments?_fieldNode$arguments:[];_fieldNode$arguments={kind:_kinds.Kind.OBJECT,fields:fieldNode.map(argNode=>({kind:_kinds.Kind.OBJECT_FIELD,name:argNode.name,value:argNode.value}))};return(0,_printer.print)((0,_sortValueNode.sortValueNode)(_fieldNode$arguments))}
function doTypesConflict(type1,type2){return(0,_definition.isListType)(type1)?(0,_definition.isListType)(type2)?doTypesConflict(type1.ofType,type2.ofType):!0:(0,_definition.isListType)(type2)?!0:(0,_definition.isNonNullType)(type1)?(0,_definition.isNonNullType)(type2)?doTypesConflict(type1.ofType,type2.ofType):!0:(0,_definition.isNonNullType)(type2)?!0:(0,_definition.isLeafType)(type1)||(0,_definition.isLeafType)(type2)?type1!==type2:!1}function getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,
parentType,selectionSet){var cached=cachedFieldsAndFragmentNames.get(selectionSet);if(cached)return cached;cached=Object.create(null);const fragmentNames=Object.create(null);_collectFieldsAndFragmentNames(context,parentType,selectionSet,cached,fragmentNames);context=[cached,Object.keys(fragmentNames)];cachedFieldsAndFragmentNames.set(selectionSet,context);return context}function getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment){var cached=cachedFieldsAndFragmentNames.get(fragment.selectionSet);
if(cached)return cached;cached=(0,_typeFromAST.typeFromAST)(context.getSchema(),fragment.typeCondition);return getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,cached,fragment.selectionSet)}function _collectFieldsAndFragmentNames(context,parentType,selectionSet,nodeAndDefs,fragmentNames){for(const selection of selectionSet.selections)switch(selection.kind){case _kinds.Kind.FIELD:selectionSet=selection.name.value;let fieldDef;if((0,_definition.isObjectType)(parentType)||(0,_definition.isInterfaceType)(parentType))fieldDef=
parentType.getFields()[selectionSet];selectionSet=selection.alias?selection.alias.value:selectionSet;nodeAndDefs[selectionSet]||(nodeAndDefs[selectionSet]=[]);nodeAndDefs[selectionSet].push([parentType,selection,fieldDef]);break;case _kinds.Kind.FRAGMENT_SPREAD:fragmentNames[selection.name.value]=!0;break;case _kinds.Kind.INLINE_FRAGMENT:selectionSet=(selectionSet=selection.typeCondition)?(0,_typeFromAST.typeFromAST)(context.getSchema(),selectionSet):parentType,_collectFieldsAndFragmentNames(context,
selectionSet,selection.selectionSet,nodeAndDefs,fragmentNames)}}function subfieldConflicts(conflicts,responseName,node1,node2){if(0<conflicts.length)return[[responseName,conflicts.map(([reason])=>reason)],[node1,...conflicts.map(([,fields1])=>fields1).flat()],[node2,...conflicts.map(([,,fields2])=>fields2).flat()]]}Object.defineProperty(exports,"__esModule",{value:!0});exports.OverlappingFieldsCanBeMergedRule=function(context){const comparedFragmentPairs=new PairSet,cachedFieldsAndFragmentNames=new Map;
return{SelectionSet(selectionSet){var parentType=context.getParentType(),conflicts=[];const [fieldMap,fragmentNames]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType,selectionSet);for(const [responseName,fields]of Object.entries(fieldMap))if(1<fields.length)for(selectionSet=0;selectionSet<fields.length;selectionSet++)for(parentType=selectionSet+1;parentType<fields.length;parentType++){const conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,!1,
responseName,fields[selectionSet],fields[parentType]);conflict&&conflicts.push(conflict)}if(0!==fragmentNames.length)for(selectionSet=0;selectionSet<fragmentNames.length;selectionSet++)for(collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,!1,fieldMap,fragmentNames[selectionSet]),parentType=selectionSet+1;parentType<fragmentNames.length;parentType++)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,
!1,fragmentNames[selectionSet],fragmentNames[parentType]);for(const [[responseName,reason],fields1,fields2]of conflicts)conflicts=reasonMessage(reason),context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${conflicts}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:fields1.concat(fields2)}))}}};var _inspect=require("module$node_modules$graphql$jsutils$inspect"),_GraphQLError=require("module$node_modules$graphql$error$GraphQLError"),
_kinds=require("module$node_modules$graphql$language$kinds"),_printer=require("module$node_modules$graphql$language$printer"),_definition=require("module$node_modules$graphql$type$definition"),_sortValueNode=require("module$node_modules$graphql$utilities$sortValueNode"),_typeFromAST=require("module$node_modules$graphql$utilities$typeFromAST");class PairSet{constructor(){this._data=new Map}has(a,b,areMutuallyExclusive){var _this$_data$get;const [key1,key2]=a<b?[a,b]:[b,a];a=null===(_this$_data$get=
this._data.get(key1))||void 0===_this$_data$get?void 0:_this$_data$get.get(key2);return void 0===a?!1:areMutuallyExclusive?!0:areMutuallyExclusive===a}add(a,b,areMutuallyExclusive){const [key1,key2]=a<b?[a,b]:[b,a];a=this._data.get(key1);void 0===a?this._data.set(key1,new Map([[key2,areMutuallyExclusive]])):a.set(key2,areMutuallyExclusive)}}}
//# sourceMappingURL=module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMergedRule.js.map
