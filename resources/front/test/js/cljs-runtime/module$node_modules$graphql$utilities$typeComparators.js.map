{
"version":3,
"file":"module$node_modules$graphql$utilities$typeComparators.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/graphql/utilities/typeComparators.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$utilities$typeComparators\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.doTypesOverlap = doTypesOverlap;\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n  if (\n    (0, _definition.isNonNullType)(typeA) &&\n    (0, _definition.isNonNullType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n  if (\n    (0, _definition.isListType)(typeA) &&\n    (0, _definition.isListType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n  return (\n    (0, _definition.isAbstractType)(superType) &&\n    ((0, _definition.isInterfaceType)(maybeSubType) ||\n      (0, _definition.isObjectType)(maybeSubType)) &&\n    schema.isSubType(superType, maybeSubType)\n  );\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema\n        .getPossibleTypes(typeA)\n        .some((type) => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n  return false;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","isEqualType","typeA","typeB","_definition","isNonNullType","isListType","ofType","isTypeSubTypeOf","schema","maybeSubType","superType","isAbstractType","isInterfaceType","isObjectType","isSubType","Object","defineProperty","value","doTypesOverlap","getPossibleTypes","some","type"]
}
