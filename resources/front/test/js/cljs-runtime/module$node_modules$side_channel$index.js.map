{
"version":3,
"file":"module$node_modules$side_channel$index.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/side-channel/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$side_channel$index\"] = function(global,require,module,exports) {\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tcurr.next = list.next;\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\nvar listGet = function (objects, key) {\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t};\n\t}\n};\nvar listHas = function (objects, key) {\n\treturn !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n\tvar $wm;\n\tvar $m;\n\tvar $o;\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif (!$wm) {\n\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t}\n\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t} else if ($Map) {\n\t\t\t\tif (!$m) {\n\t\t\t\t\t$m = new $Map();\n\t\t\t\t}\n\t\t\t\t$mapSet($m, key, value);\n\t\t\t} else {\n\t\t\t\tif (!$o) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t */\n\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t}\n\t\t\t\tlistSet($o, key, value);\n\t\t\t}\n\t\t}\n\t};\n\treturn channel;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","GetIntrinsic","callBound","inspect","$TypeError","$WeakMap","$Map","$weakMapGet","$weakMapSet","$weakMapHas","$mapGet","$mapSet","$mapHas","listGetNode","list","key","prev","curr","next","module.exports","$wm","$m","$o","channel","assert","has","get","node","value","set","objects"]
}
