{"version":3,"sources":["promesa/exec.cljc"],"mappings":"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","names":["js/promesa","js/promesa.exec","js/promesa.exec.*default-scheduler*","promesa.exec/*default-scheduler*","cljs.core/Delay","promesa.exec/->ScheduledExecutor","js/promesa.exec.*default-executor*","promesa.exec/*default-executor*","promesa.exec/->MicrotaskExecutor","js/promesa.exec.same-thread-executor","promesa.exec/same-thread-executor","promesa.exec/->SameThreadExecutor","promesa.exec/vthreads-supported?","js/promesa.exec.*vthread-executor*","promesa.exec/*vthread-executor*","js/promesa.exec.*thread-executor*","promesa.exec/*thread-executor*","promesa.exec/executor?","o","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IExecutor","var_args","G__52093","promesa.exec/resolve-executor","js/Error","promesa.exec.resolve_executor","executor","G__52095","cljs.core/Keyword","promesa.util/maybe-deref","G__52103","promesa.exec/resolve-scheduler","promesa.exec.resolve_scheduler","scheduler","cljs.core._EQ_","promesa.exec/wrap-bindings","f","promesa.exec/noop","cljs.core/constantly","G__52108","promesa.exec/run!","promesa.protocols/-submit!","cljs.core.comp","G__52113","promesa.exec/submit!","G__52115","promesa.exec/schedule!","ms","promesa.protocols/-schedule!","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","promesa.exec/MicrotaskExecutor","this","promesa.protocols/-promise","promesa.protocols/-map","_","promesa.protocols/-mapErr","e","js/setTimeout","promesa.exec/SameThreadExecutor","promesa.exec/ScheduledTask","promesa.exec/->ScheduledTask","state","done-iref","promesa.exec.goog$module$goog$object.get","cljs.core/deref","self","cancel-fn","promesa.exec.goog$module$goog$object.set","promesa.exec/ScheduledExecutor","done","cljs.core/volatile!","task","cljs.core/vreset!","tid","cancel","js/clearTimeout"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns promesa.exec\n  \"Executors & Schedulers facilities.\"\n  (:refer-clojure :exclude [run!])\n  (:require [promesa.protocols :as pt]\n            [promesa.util :as pu]\n            #?(:cljs [goog.object :as gobj]))\n  #?(:clj\n     (:import\n      java.lang.AutoCloseable\n      java.util.concurrent.Callable\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.Executor\n      java.util.concurrent.ExecutorService\n      java.util.concurrent.Executors\n      java.util.concurrent.ForkJoinPool\n      java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory\n      java.util.concurrent.ForkJoinWorkerThread\n      java.util.concurrent.Future\n      java.util.concurrent.ScheduledExecutorService\n      java.util.concurrent.ThreadFactory\n      java.util.concurrent.TimeUnit\n      java.util.concurrent.TimeoutException\n      java.util.concurrent.atomic.AtomicLong\n      java.util.function.Supplier\n      promesa.exec.ConcurrencyLimiter)))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; --- Globals & Defaults (with CLJS Impl)\n\n#?(:clj (declare scheduled-pool)\n   :cljs (declare ->ScheduledExecutor))\n\n#?(:clj (declare cached-executor)\n   :cljs (declare ->MicrotaskExecutor))\n\n(declare ->SameThreadExecutor)\n\n(defonce ^:dynamic *default-scheduler*\n  (delay #?(:clj (scheduled-pool)\n            :cljs (->ScheduledExecutor))))\n\n(defonce ^:dynamic *default-executor*\n  (delay #?(:clj (ForkJoinPool/commonPool)\n            :cljs (->MicrotaskExecutor))))\n\n(defonce same-thread-executor\n  (delay (->SameThreadExecutor)))\n\n(def vthreads-supported?\n  #?(:clj (and (pu/has-method? Thread \"startVirtualThread\")\n               (try\n                 (eval '(Thread/startVirtualThread (constantly nil)))\n                 true\n                 (catch Throwable cause\n                   false)))\n     :cljs false))\n\n(defonce ^:dynamic *vthread-executor*\n  #?(:clj (when vthreads-supported?\n            (delay (eval '(java.util.concurrent.Executors/newVirtualThreadPerTaskExecutor))))\n     :cljs (delay (->MicrotaskExecutor))))\n\n(defonce ^:dynamic *thread-executor*\n  #?(:clj  (delay (cached-executor))\n     :cljs (delay (->MicrotaskExecutor))))\n\n(defn executor?\n  [o]\n  #?(:clj (instance? Executor o)\n     :cljs (satisfies? pt/IExecutor o)))\n\n(defn resolve-executor\n  ([] (resolve-executor :default))\n  ([executor]\n   (case executor\n     :default (pu/maybe-deref *default-executor*)\n     :thread  (pu/maybe-deref *thread-executor*)\n     :vthread (do\n                #?(:clj\n                   (when (nil? *vthread-executor*)\n                     (throw (UnsupportedOperationException. \"vthreads not available\"))))\n                (pu/maybe-deref *vthread-executor*))\n     (pu/maybe-deref executor))))\n\n(defn resolve-scheduler\n  ([] (resolve-scheduler :default))\n  ([scheduler]\n   (if (= :default scheduler)\n     (pu/maybe-deref *default-scheduler*)\n     (pu/maybe-deref scheduler))))\n\n#?(:clj\n   (defn- get-available-processors\n     []\n     (.availableProcessors (Runtime/getRuntime))))\n\n(defn wrap-bindings\n  [f]\n  #?(:cljs f\n     :clj\n     (let [frame (clojure.lang.Var/cloneThreadBindingFrame)]\n       (fn\n         ([]\n          (clojure.lang.Var/resetThreadBindingFrame frame)\n          (f))\n         ([x]\n          (clojure.lang.Var/resetThreadBindingFrame frame)\n          (f x))\n         ([x y]\n          (clojure.lang.Var/resetThreadBindingFrame frame)\n          (f x y))\n         ([x y z]\n          (clojure.lang.Var/resetThreadBindingFrame frame)\n          (f x y z))\n         ([x y z & args]\n          (clojure.lang.Var/resetThreadBindingFrame frame)\n          (apply f x y z args))))))\n\n;; --- Public API\n\n(def noop (constantly nil))\n\n(defn run!\n  \"Run the task in the provided executor.\"\n  ([f]\n   (pt/-submit! (resolve-executor) (comp noop f)))\n  ([executor f]\n   (pt/-submit! (resolve-executor executor) (comp noop f))))\n\n(defn submit!\n  \"Submit a task to be executed in a provided executor\n  and return a promise that will be completed with\n  the return value of a task.\n\n  A task is a plain clojure function.\"\n  ([f]\n   (pt/-submit! (resolve-executor) f))\n  ([executor f]\n   (pt/-submit! (resolve-executor executor) f)))\n\n(defn schedule!\n  \"Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function.\"\n  ([ms f]\n   (pt/-schedule! (resolve-scheduler) ms f))\n  ([scheduler ms f]\n   (pt/-schedule! (resolve-scheduler scheduler) ms f)))\n\n;; --- Pool & Thread Factories\n\n#?(:clj\n   (defn thread-factory?\n     [o]\n     (instance? ThreadFactory o)))\n\n#?(:clj\n   (defn- fn->thread-factory\n     \"Adapt a simple clojure function into a ThreadFactory instance.\"\n     [func]\n     (reify ThreadFactory\n       (^Thread newThread [_ ^Runnable runnable]\n        (func runnable)))))\n\n#?(:clj (def counter (AtomicLong. 0)))\n\n#?(:clj\n   (defn default-thread-factory\n     [& {:keys [name daemon priority]\n         :or {daemon true\n              priority Thread/NORM_PRIORITY\n              name \"promesa/thread/%s\"}}]\n     (reify ThreadFactory\n       (newThread [this runnable]\n         (doto (Thread. ^Runnable runnable)\n           (.setPriority priority)\n           (.setDaemon ^Boolean daemon)\n           (.setName (format name (.getAndIncrement ^AtomicLong counter))))))))\n\n#?(:clj\n   (defn default-forkjoin-thread-factory\n     ^ForkJoinPool$ForkJoinWorkerThreadFactory\n     [& {:keys [name daemon] :or {name \"promesa/forkjoin/%s\" daemon true}}]\n     (let [^AtomicLong counter (AtomicLong. 0)]\n       (reify ForkJoinPool$ForkJoinWorkerThreadFactory\n         (newThread [_ pool]\n           (let [thread (.newThread ForkJoinPool/defaultForkJoinWorkerThreadFactory pool)\n                 tname  (format name (.getAndIncrement counter))]\n             (.setName ^ForkJoinWorkerThread thread ^String tname)\n             (.setDaemon ^ForkJoinWorkerThread thread ^Boolean daemon)\n             thread))))))\n\n#?(:clj\n   (defn- opts->thread-factory\n     [{:keys [daemon priority]\n       :or {daemon true priority Thread/NORM_PRIORITY}}]\n     (fn->thread-factory\n      (fn [runnable]\n        (let [thread (Thread. ^Runnable runnable)]\n          (.setDaemon thread daemon)\n          (.setPriority thread priority)\n          thread)))))\n\n#?(:clj\n   (defn- resolve-thread-factory\n     ^ThreadFactory\n     [opts]\n     (cond\n       (thread-factory? opts) opts\n       (= :default opts)      (default-thread-factory)\n       (nil? opts)            (default-thread-factory)\n       (map? opts)            (default-thread-factory opts)\n       (fn? opts)             (fn->thread-factory opts)\n       :else                  (throw (ex-info \"Invalid thread factory\" {})))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; --- DEPRECATED\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (defn cached-pool\n     \"A cached thread pool constructor.\"\n     {:deprecated \"9.0\"}\n     ([]\n      (Executors/newCachedThreadPool))\n     ([opts]\n      (let [factory (resolve-thread-factory opts)]\n        (Executors/newCachedThreadPool factory)))))\n\n#?(:clj\n   (defn fixed-pool\n     \"A fixed thread pool constructor.\"\n     {:deprecated \"9.0\"}\n     ([n]\n      (Executors/newFixedThreadPool (int n)))\n     ([n opts]\n      (let [factory (resolve-thread-factory opts)]\n        (Executors/newFixedThreadPool (int n) factory)))))\n\n#?(:clj\n   (defn single-pool\n     \"A single thread pool constructor.\"\n     {:deprecated \"9.0\"}\n     ([]\n      (Executors/newSingleThreadExecutor))\n     ([opts]\n      (let [factory (resolve-thread-factory opts)]\n        (Executors/newSingleThreadExecutor factory)))))\n\n#?(:clj\n   (defn scheduled-pool\n     \"A scheduled thread pool constructor.\"\n     {:deprecated \"9.0\"}\n     ([] (Executors/newScheduledThreadPool (int 0)))\n     ([n] (Executors/newScheduledThreadPool (int n)))\n     ([n opts]\n      (let [factory (resolve-thread-factory opts)]\n        (Executors/newScheduledThreadPool (int n) factory)))))\n\n#?(:clj\n   (defn work-stealing-pool\n     \"Creates a work-stealing thread pool.\"\n     {:deprecated \"9.0\"}\n     ([] (Executors/newWorkStealingPool))\n     ([n] (Executors/newWorkStealingPool (int n)))))\n\n#?(:clj\n   (defn forkjoin-pool\n     {:deprecated \"9.0\"}\n     [{:keys [factory async? parallelism]\n       :or {async? true}\n       :as opts}]\n     (let [parallelism (or parallelism (get-available-processors))\n           factory     (cond\n                         (instance? ForkJoinPool$ForkJoinWorkerThreadFactory factory) factory\n                         (nil? factory) ForkJoinPool/defaultForkJoinWorkerThreadFactory\n                         :else (throw (ex-info \"Unexpected thread factory\" {:factory factory})))]\n       (ForkJoinPool. parallelism factory nil async?))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; --- END DEPRECATED\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (defn cached-executor\n     \"A cached thread executor pool constructor.\"\n     [& {:keys [factory]}]\n     (let [factory (or (some-> factory resolve-thread-factory)\n                       (default-thread-factory :name \"promesa/cached/%s\"))]\n       (Executors/newCachedThreadPool factory))))\n\n#?(:clj\n   (defn fixed-executor\n     \"A fixed thread executor pool constructor.\"\n     [& {:keys [parallelism factory]}]\n     (let [factory (or (some-> factory resolve-thread-factory)\n                       (default-thread-factory :name \"promesa/fixed/%s\"))]\n       (Executors/newFixedThreadPool (int parallelism) factory))))\n\n#?(:clj\n   (defn single-executor\n     \"A single thread executor pool constructor.\"\n     [& {:keys [factory]}]\n     (let [factory (or (some-> factory resolve-thread-factory)\n                       (default-thread-factory :name \"promesa/single/%s\"))]\n       (Executors/newSingleThreadExecutor factory))))\n\n#?(:clj\n   (defn scheduled-executor\n     \"A scheduled thread pool constructor.\"\n     [& {:keys [parallelism factory] :or {parallelism 1}}]\n     (let [factory (or (some-> factory resolve-thread-factory)\n                       (default-thread-factory :name \"promesa/scheduled/%s\"))]\n       (Executors/newScheduledThreadPool (int parallelism) factory))))\n\n#?(:clj\n   (when vthreads-supported?\n     (eval\n      '(defn thread-per-task-executor\n         [& {:keys [factory]}]\n         (let [factory (or (some-> factory resolve-thread-factory)\n                           (default-thread-factory :name \"promesa/thread-per-task/%s\"))]\n           (Executors/newThreadPerTaskExecutor ^ThreadFactory factory))))))\n\n#?(:clj\n   (when vthreads-supported?\n     (eval\n      '(defn vthread-per-task-executor\n         []\n         (Executors/newVirtualThreadPerTaskExecutor)))))\n\n#?(:clj\n   (defn forkjoin-executor\n     [& {:keys [factory async? parallelism] :or {async? true}}]\n     (let [parallelism (or parallelism (get-available-processors))\n           factory     (cond\n                         (instance? ForkJoinPool$ForkJoinWorkerThreadFactory factory) factory\n                         (nil? factory) (default-forkjoin-thread-factory)\n                         :else (throw (ex-info \"Unexpected thread factory\" {:factory factory})))]\n       (ForkJoinPool. (int parallelism) factory nil async?))))\n\n#?(:clj\n   (defn work-stealing-executor\n     \"An alias for the `forkjoin-executor`.\"\n     [& params]\n     (apply forkjoin-executor params)))\n\n#?(:clj\n   (defn configure-default-executor!\n     [& params]\n     (alter-var-root #'*default-executor*\n                     (fn [executor]\n                       (when (and (delay? executor) (realized? executor))\n                         (.close ^AutoCloseable @executor))\n                       (when (instance? AutoCloseable executor)\n                         (.close ^AutoCloseable executor))\n                       (apply forkjoin-executor params)))))\n\n#?(:clj\n   (extend-protocol pt/IExecutor\n     Executor\n     (-submit! [this f]\n       (CompletableFuture/supplyAsync ^Supplier (pu/->SupplierWrapper f) ^Executor this))))\n\n;; Default executor that executes cljs/js tasks in the microtask\n;; queue.\n#?(:cljs\n   (deftype MicrotaskExecutor []\n     pt/IExecutor\n     (-submit! [this f]\n       (-> (pt/-promise nil)\n           (pt/-map (fn [_] (f)))\n           (pt/-mapErr (fn [e] (js/setTimeout #(throw e)) nil))))))\n\n;; Executor that executes the task in the calling thread\n#?(:clj\n   (deftype SameThreadExecutor []\n     Executor\n     (^void execute [_ ^Runnable f]\n       (.run f)))\n\n   :cljs\n   (deftype SameThreadExecutor []\n     pt/IExecutor\n     (-submit! [this f]\n       (pt/-promise (f)))))\n\n;; --- Scheduler & ScheduledTask\n\n#?(:clj\n   (deftype ScheduledTask [^Future fut]\n     clojure.lang.IDeref\n     (deref [_] (.get fut))\n\n     clojure.lang.IBlockingDeref\n     (deref [_ ms default]\n       (try\n         (.get fut ms TimeUnit/MILLISECONDS)\n         (catch TimeoutException e\n           default)))\n\n     clojure.lang.IPending\n     (isRealized [_] (and (.isDone fut)\n                          (not (.isCancelled fut))))\n\n     pt/ICancellable\n     (-cancelled? [_]\n       (.isCancelled fut))\n     (-cancel! [_]\n       (when-not (.isCancelled fut)\n         (.cancel fut true)))\n\n     Future\n     (get [_] (.get fut))\n     (get [_ timeout unit] (.get fut timeout unit))\n     (isCancelled [_] (.isCancelled fut))\n     (isDone [_] (.isDone fut))\n     (cancel [_ interrupt?] (.cancel fut interrupt?)))\n\n   :cljs\n   (deftype ScheduledTask [state]\n     cljs.core/IPending\n     (-realized? [_]\n       (let [done-iref (gobj/get state \"done\")]\n         (deref done-iref)))\n\n     pt/ICancellable\n     (-cancelled? [_]\n       (gobj/get state \"cancelled\"))\n     (-cancel! [self]\n       (when-not (pt/-cancelled? self)\n         (let [cancel-fn (gobj/get state \"cancel-fn\")]\n           (gobj/set state \"cancelled\" true)\n           (cancel-fn))))))\n\n#?(:clj\n   (extend-type ScheduledExecutorService\n     pt/IScheduler\n     (-schedule! [this ms f]\n       (let [fut (.schedule this ^Callable f ^long ms TimeUnit/MILLISECONDS)]\n         (ScheduledTask. fut)))))\n\n#?(:cljs\n   (deftype ScheduledExecutor []\n     pt/IScheduler\n     (-schedule! [_ ms f]\n       (let [done (volatile! false)\n             task #(try\n                     (f)\n                     (finally\n                       (vreset! done true)))\n             tid (js/setTimeout task ms)\n             cancel #(js/clearTimeout tid)]\n         (->ScheduledTask #js {:done done\n                               :cancelled false\n                               :cancel-fn cancel})))))\n\n(defmacro with-dispatch\n  \"Helper macro for dispatch execution of the body to an executor\n  service. The returned promise is not cancellable (the body will be\n  executed independently of the cancellation).\"\n  [executor & body]\n  `(-> (submit! ~executor (^:once fn* [] (pt/-promise (do ~@body))))\n       (pt/-bind identity)))\n\n#?(:clj\n   (defn concurrency-limiter\n     \"Create an instance of concurrencly limiter. EXPERIMENTAL\"\n     [& {:keys [executor concurrency queue-size on-run on-queue]\n         :or {concurrency 1 queue-size Integer/MAX_VALUE}}]\n     (let [^ExecutorService executor (resolve-executor (or executor *default-executor*))]\n       (doto (ConcurrencyLimiter. executor (int concurrency) (int queue-size))\n         (cond-> (fn? on-queue) (.setOnQueueCallback on-queue))\n         (cond-> (fn? on-run) (.setOnRunCallback on-run))))))\n\n#?(:clj\n   (extend-type ConcurrencyLimiter\n     pt/IExecutor\n     (-submit! [this f] (this f))))\n"]}