{
"version":3,
"file":"module$node_modules$graphql$execution$execute.js",
"lineCount":30,
"mappings":"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",
"sources":["node_modules/graphql/execution/execute.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$execution$execute\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidExecutionArguments = assertValidExecutionArguments;\nexports.buildExecutionContext = buildExecutionContext;\nexports.buildResolveInfo = buildResolveInfo;\nexports.defaultTypeResolver = exports.defaultFieldResolver = void 0;\nexports.execute = execute;\nexports.executeSync = executeSync;\nexports.getFieldDef = getFieldDef;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _isPromise = require('../jsutils/isPromise.js');\n\nvar _memoize = require('../jsutils/memoize3.js');\n\nvar _Path = require('../jsutils/Path.js');\n\nvar _promiseForObject = require('../jsutils/promiseForObject.js');\n\nvar _promiseReduce = require('../jsutils/promiseReduce.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _locatedError = require('../error/locatedError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _validate = require('../type/validate.js');\n\nvar _collectFields = require('./collectFields.js');\n\nvar _values = require('./values.js');\n\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = (0, _memoize.memoize3)(\n  (exeContext, returnType, fieldNodes) =>\n    (0, _collectFields.collectSubfields)(\n      exeContext.schema,\n      exeContext.fragments,\n      exeContext.variableValues,\n      returnType,\n      fieldNodes,\n    ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nfunction execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    (0, _devAssert.devAssert)(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if ((0, _isPromise.isPromise)(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nfunction executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if ((0, _isPromise.isPromise)(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nfunction assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || (0, _devAssert.devAssert)(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    (0, _isObjectLike.isObjectLike)(rawVariableValues) ||\n    (0, _devAssert.devAssert)(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nfunction buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new _GraphQLError.GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [\n        new _GraphQLError.GraphQLError(\n          `Unknown operation named \"${operationName}\".`,\n        ),\n      ];\n    }\n\n    return [new _GraphQLError.GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = (0, _values.getVariableValues)(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = (0, _collectFields.collectFields)(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case _ast.OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return (0, _promiseReduce.promiseReduce)(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if ((0, _isPromise.isPromise)(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n    const result = executeField(\n      exeContext,\n      parentType,\n      sourceValue,\n      fieldNodes,\n      fieldPath,\n    );\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if ((0, _isPromise.isPromise)(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return (0, _promiseForObject.promiseForObject)(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = (0, _values.getArgumentValues)(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if ((0, _isPromise.isPromise)(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if ((0, _isPromise.isPromise)(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = (0, _locatedError.locatedError)(\n          rawError,\n          fieldNodes,\n          (0, _Path.pathToArray)(path),\n        );\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = (0, _locatedError.locatedError)(\n      rawError,\n      fieldNodes,\n      (0, _Path.pathToArray)(path),\n    );\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if ((0, _definition.isNonNullType)(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if ((0, _definition.isNonNullType)(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if ((0, _definition.isListType)(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if ((0, _definition.isLeafType)(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if ((0, _definition.isAbstractType)(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if ((0, _definition.isObjectType)(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Cannot complete value of unexpected output type: ' +\n        (0, _inspect.inspect)(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!(0, _isIterableObject.isIterableObject)(result)) {\n    throw new _GraphQLError.GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = (0, _Path.addPath)(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if ((0, _isPromise.isPromise)(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if ((0, _isPromise.isPromise)(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = (0, _locatedError.locatedError)(\n            rawError,\n            fieldNodes,\n            (0, _Path.pathToArray)(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = (0, _locatedError.locatedError)(\n        rawError,\n        fieldNodes,\n        (0, _Path.pathToArray)(itemPath),\n      );\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${(0, _inspect.inspect)(returnType)}.serialize(${(0,\n      _inspect.inspect)(result)})\\` to ` +\n        `return non-nullable value, returned: ${(0, _inspect.inspect)(\n          serializedResult,\n        )}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if ((0, _isPromise.isPromise)(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if ((0, _definition.isObjectType)(runtimeTypeName)) {\n    throw new _GraphQLError.GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${(0, _inspect.inspect)(result)}, received \"${(0,\n        _inspect.inspect)(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!(0, _definition.isObjectType)(runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if ((0, _isPromise.isPromise)(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new _GraphQLError.GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${(0,\n    _inspect.inspect)(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nconst defaultTypeResolver = function (value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (\n    (0, _isObjectLike.isObjectLike)(value) &&\n    typeof value.__typename === 'string'\n  ) {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if ((0, _isPromise.isPromise)(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexports.defaultTypeResolver = defaultTypeResolver;\n\nconst defaultFieldResolver = function (source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if ((0, _isObjectLike.isObjectLike)(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexports.defaultFieldResolver = defaultFieldResolver;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === _introspection.SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.SchemaMetaFieldDef;\n  } else if (\n    fieldName === _introspection.TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.TypeMetaFieldDef;\n  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","execute","args","arguments","length","_devAssert","devAssert","schema","document","variableValues","rootValue","assertValidExecutionArguments","exeContext","buildExecutionContext","errors","operation","result","executeOperation","_isPromise","isPromise","then","data","buildResponse","error","push","rawVariableValues","_validate","assertValidSchema","_isObjectLike","isObjectLike","_definition$name","_operation$variableDe","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","fragments","Object","create","definition","definitions","kind","_kinds","Kind","OPERATION_DEFINITION","undefined","_GraphQLError","GraphQLError","name","value","FRAGMENT_DEFINITION","variableDefinitions","coercedVariableValues","_values","getVariableValues","maxErrors","coerced","defaultFieldResolver","defaultTypeResolver","rootType","getRootType","nodes","rootFields","_collectFields","collectFields","selectionSet","_ast","OperationTypeNode","QUERY","executeFields","MUTATION","executeFieldsSerially","SUBSCRIPTION","parentType","sourceValue","path","fields","_promiseReduce","promiseReduce","entries","results","responseName","fieldNodes","fieldPath","_Path","addPath","executeField","resolvedResult","containsPromise","_promiseForObject","promiseForObject","source","_fieldDef$resolve","fieldDef","getFieldDef","returnType","type","resolveFn","resolve","info","buildResolveInfo","getArgumentValues","completed","resolved","completeValue","rawError","_locatedError","locatedError","pathToArray","handleFieldError","fieldName","_definition","isNonNullType","Error","ofType","isListType","completeListValue","isLeafType","serializedResult","serialize","_inspect","inspect","isAbstractType","completeAbstractValue","isObjectType","completeObjectValue","_invariant","invariant","_isIterableObject","isIterableObject","itemType","completedResults","Array","from","item","index","itemPath","completedItem","Promise","all","_returnType$resolveTy","runtimeType","resolveTypeFn","resolveType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","getType","isSubType","subFieldNodes","collectSubfields","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","fieldNode","_introspection","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","getFields","defineProperty","executeSync","_memoize","memoize3","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","i","isTypeOfResult","isTypeOfResults","property"]
}
