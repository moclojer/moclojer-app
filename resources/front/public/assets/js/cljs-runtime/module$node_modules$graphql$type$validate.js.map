{
"version":3,
"file":"module$node_modules$graphql$type$validate.js",
"lineCount":28,
"mappings":"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",
"sources":["node_modules/graphql/type/validate.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$type$validate\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidSchema = assertValidSchema;\nexports.validateSchema = validateSchema;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _typeComparators = require('../utilities/typeComparators.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\nvar _schema = require('./schema.js');\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nfunction assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new _GraphQLError.GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${(0,\n      _inspect.inspect)(queryType)}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError(\n        `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!(0, _definition.isOutputType)(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError(\n        `Type ${(0, _inspect.inspect)(\n          type,\n        )} must only implement Interface types, ` +\n          `it cannot implement ${(0, _inspect.inspect)(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (\n      !(0, _typeComparators.isTypeSubTypeOf)(\n        context.schema,\n        typeField.type,\n        ifaceField.type,\n      )\n    ) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${(0, _inspect.inspect)(ifaceField.type)} but ${\n            type.name\n          }.${fieldName} ` +\n          `is type ${(0, _inspect.inspect)(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${(0, _inspect.inspect)(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${(0, _inspect.inspect)(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!(0, _definition.isInputType)(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (\n      (0, _definition.isRequiredInputField)(field) &&\n      field.deprecationReason != null\n    ) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (\n        (0, _definition.isNonNullType)(field.type) &&\n        (0, _definition.isInputObjectType)(field.type.ofType)\n      ) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) =>\n          node.name.value === _directives.GraphQLDeprecatedDirective.name,\n      );\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","validateSchema","schema","_schema","assertSchema","__validationErrors","context","SchemaValidationContext","queryType","getQueryType","reportError","astNode","_definition","isObjectType","_getOperationTypeNode","_inspect","inspect","getOperationTypeNode","_ast","OperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","directive","getDirectives","_directives","isDirective","validateName","arg","args","isInputType","type","name","isRequiredArgument","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","isNamedType","_introspection","isIntrospectionType","validateFields","validateInterfaces","isInterfaceType","isUnionType","memberTypes","union","getTypes","length","extensionASTNodes","includedTypeNames","create","memberType","getUnionMemberTypeNodes","String","isEnumType","enumValues","enumType","getValues","enumValue","isInputObjectType","fields","inputObj","getFields","field","_field$astNode2","isRequiredInputField","_field$astNode3","errors","getErrors","operation","_flatMap$find","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","node","startsWith","isOutputType","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","iface","getInterfaces","getAllImplementsInterfaceNodes","ifaceInterfaces","transitive","includes","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_typeComparators","isTypeSubTypeOf","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","isEqualType","_ifaceArg$astNode","_typeArg$astNode","detectCycleRecursive","visitedTypes","fieldPathIndexByTypeName","fieldPath","isNonNullType","ofType","fieldType","cycleIndex","push","undefined","cyclePath","slice","pathStr","map","fieldObj","join","pop","nodes","typeNode","_typeNode$interfaces","interfaces","filter","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives","GraphQLDeprecatedDirective","defineProperty","assertValidSchema","Error","error","message","_GraphQLError","constructor","_errors","_nodes","Array","isArray","Boolean","GraphQLError"]
}
