{"version":3,"sources":["app/dev.cljs"],"mappings":";AASA,AAACA;AAYD,kBAAA,lBAAuBC;AAAvB,AACE,AAACC;;AACD,OAACC;;AAEH,AAAKC,uBAAgBC;AAErB,oBAAA,pBAAMC;AAAN,AACE,GAAMF;AAAN,AACE,AAACG;;AACD,gHAAA,zGAACC;;AAFH","names":["helix.experimental.refresh/inject-hook!","app.dev/refresh","refx.alpha/clear-subscription-cache!","helix.experimental.refresh/refresh!","app.dev/debug?","js/goog.DEBUG","app.dev/dev-setup","cljs.core/enable-console-print!","cljs.core.println"],"sourcesContent":["(ns app.dev\n  \"A place to add preloads for developer tools!\"\n  (:require\n   [helix.experimental.refresh :as r]\n   [refx.alpha :as refx]))\n\n;; inject-hook! needs to run on application start.\n;; For ease, we run it at the top level.\n;; This function adds the react-refresh runtime to the page\n(r/inject-hook!)\n\n;; shadow-cljs allows us to annotate a function name with `:dev/after-load`\n;; to signal that it should be run after any code reload. We call the `refresh!`\n;; function, which will tell react to refresh any components which have a\n;; signature created by turning on the `:fast-refresh` feature flag.\n\n;; The `:dev/after-load` metadata causes this function to be called\n;; after shadow-cljs hot-reloads code. We force a UI update by clearing\n;; the Reframe subscription cache.\n\n#_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]}\n(defn ^:dev/after-load refresh []\n  (refx/clear-subscription-cache!)\n  (r/refresh!))\n\n(def debug? ^boolean goog.DEBUG)\n\n(defn dev-setup []\n  (when debug?\n    (enable-console-print!)\n    (println \"dev mode\")))\n\n"]}