{
"version":3,
"file":"module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$path_match.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,iGAAA,CAAsH,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAE9JC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CACzCG,MAAO,CAAA,CADkC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAGAA,QAAqB,CAACC,IAAD,CAAOC,OAAP,CAAgB,CACjC,MAAMC,KAAO,EACPC,KAAAA,CAA4BC,CAAlB,CAAA,CAAGC,aAAeD,EAAAA,YAAnB,CAAgCJ,IAAhC,CAAsCE,IAAtC,CAA4C,CACvDI,UAAW,GAD4C,CAEvDC,UAAW,CAAA,CAF4C,CAGvDC,OAAmB,IAAX,EAAAP,OAAA,CAAkB,IAAK,EAAvB,CAA2BA,OAAQO,CAAAA,MAHY,CAA5C,CAKf,OAAMC,QAA6BC,CAAlB,CAAA,CAAGL,aAAeK,EAAAA,gBAAnB,CAAoC,CAAY,IAAX,EAAAT,OAAA,CAAkB,CAAlB,CAA2BA,OAAQU,CAAAA,aAApC,EAAqD,IAAIC,MAAJ,CAAWX,OAAQU,CAAAA,aAAR,CAAsBR,IAAOU,CAAAA,MAA7B,CAAX;AAAiDV,IAAOW,CAAAA,KAAxD,CAArD,CAAsHX,IAA1J,CAAkKD,IAAlK,CAMd,OAAO,CAACa,QAAD,CAAWC,MAAX,CAAA,EAAoB,CACnBC,QAAAA,CAAkB,IAAZ,EAAAF,QAAA,CAAmB,CAAA,CAAnB,CAA2BN,OAAA,CAAQM,QAAR,CACvC,IAAI,CAACE,QAAL,CACI,MAAO,CAAA,CAMX,IAAe,IAAX,EAAAhB,OAAA,CAAkB,CAAlB,CAA2BA,OAAQiB,CAAAA,mBAAvC,CACI,IAAK,MAAMC,GAAX,GAAkBjB,KAAlB,CAC4B,QAAxB,GAAI,MAAOiB,IAAIC,CAAAA,IAAf,EACI,OAAOH,QAAID,CAAAA,MAAJ,CAAWG,GAAIC,CAAAA,IAAf,CAInB,OAAOC,SAAA,CAAS,EAAT,CAAaL,MAAb,CAAqBC,QAAID,CAAAA,MAAzB,CAhBkB,CAbI,CAFrC,KAAIK,SAAW5B,OAAA,CAAQ,gFAAR,CAAwC6B,CAAAA,OAAvD,CACIjB,cAAgBZ,OAAA,CAAQ,8FAAR,CAP0I;",
"sources":["node_modules/moclojer-components/node_modules/next/dist/shared/lib/router/utils/path-match.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$path_match\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getPathMatch = getPathMatch;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n    const keys = [];\n    const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n        delimiter: '/',\n        sensitive: false,\n        strict: options == null ? void 0 : options.strict\n    });\n    const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n    /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */ return (pathname, params)=>{\n        const res = pathname == null ? false : matcher(pathname);\n        if (!res) {\n            return false;\n        }\n        /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */ if (options == null ? void 0 : options.removeUnnamedParams) {\n            for (const key of keys){\n                if (typeof key.name === 'number') {\n                    delete res.params[key.name];\n                }\n            }\n        }\n        return _extends({}, params, res.params);\n    };\n}\n\n//# sourceMappingURL=path-match.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","getPathMatch","path","options","keys","regexp","pathToRegexp","_pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","res","removeUnnamedParams","key","name","_extends","default"]
}
