{
"version":3,
"file":"module$node_modules$graphql$validation$rules$NoFragmentCyclesRule.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,oBAAR,CAYAA,QAA6B,CAACC,OAAD,CAAU,CAmBrCC,QAASA,qBAAoB,CAACC,QAAD,CAAW,CACtC,GAAI,CAAAC,YAAA,CAAaD,QAASE,CAAAA,IAAKN,CAAAA,KAA3B,CAAJ,CAAA,CAIA,IAAMO,aAAeH,QAASE,CAAAA,IAAKN,CAAAA,KACnCK,aAAA,CAAaE,YAAb,CAAA,CAA6B,CAAA,CACvBC,SAAAA,CAAcN,OAAQO,CAAAA,kBAAR,CAA2BL,QAASM,CAAAA,YAApC,CAEpB,IAA2B,CAA3B,GAAIF,QAAYG,CAAAA,MAAhB,CAAA,CAIAC,qBAAA,CAAsBL,YAAtB,CAAA,CAAsCM,UAAWF,CAAAA,MAEjD;IAAK,MAAMG,UAAX,GAAyBN,SAAzB,CAAsC,CAC9BO,QAAAA,CAAaD,UAAWR,CAAAA,IAAKN,CAAAA,KACnC,KAAMgB,WAAaJ,qBAAA,CAAsBG,QAAtB,CACnBF,WAAWI,CAAAA,IAAX,CAAgBH,UAAhB,CAEA,IAAmBI,IAAAA,EAAnB,GAAIF,UAAJ,CAGE,CAFMG,QAEN,CAFuBjB,OAAQkB,CAAAA,WAAR,CAAoBL,QAApB,CAEvB,GACEZ,oBAAA,CAAqBgB,QAArB,CAJJ,KAMO,CACCE,UAAAA,CAAYR,UAAWS,CAAAA,KAAX,CAAiBN,UAAjB,CAClB,OAAMO,QAAUF,UACbC,CAAAA,KADa,CACP,CADO,CACJ,CAAC,CADG,CAEbE,CAAAA,GAFa,CAERC,CAAD,EAAO,GAAP,CAAaA,CAAEnB,CAAAA,IAAKN,CAAAA,KAApB,CAA4B,GAFnB,CAGb0B,CAAAA,IAHa,CAGR,IAHQ,CAIhBxB,QAAQyB,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,2BAA0Bd,QAA1B,iBADH,EAEiB,EAAZ,GAAAQ,OAAA,CAAkB,QAAOA,OAAP,GAAlB,CAAsC,GAF3C,EAGE,CACEO,MAAOT,UADT,CAHF,CADF,CANK,CAiBPR,UAAWkB,CAAAA,GAAX,EA5BoC,CA+BtCnB,qBAAA,CAAsBL,YAAtB,CAAA;AAAsCW,IAAAA,EArCtC,CARA,CADsC,CAhBxC,MAAMb,aAAeP,MAAOkC,CAAAA,MAAP,CAAc,IAAd,CAArB,CAEMnB,WAAa,EAFnB,CAIMD,sBAAwBd,MAAOkC,CAAAA,MAAP,CAAc,IAAd,CAC9B,OAAO,CACLC,oBAAqB,EAAAA,EAAM,CAAA,CADtB,CAGLC,kBAAkB,CAACC,IAAD,CAAO,CACvBhC,oBAAA,CAAqBgC,IAArB,CACA,OAAO,CAAA,CAFgB,CAHpB,CAR8B,CAVvC,KAAIP,cAAgBjC,OAAA,CAAQ,gDAAR,CAR0G;",
"sources":["node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$NoFragmentCyclesRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoFragmentCyclesRule = NoFragmentCyclesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nfunction NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","NoFragmentCyclesRule","context","detectCycleRecursive","fragment","visitedFrags","name","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","length","spreadPathIndexByName","spreadPath","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","viaPath","map","s","join","reportError","_GraphQLError","GraphQLError","nodes","pop","create","OperationDefinition","FragmentDefinition","node"]
}
