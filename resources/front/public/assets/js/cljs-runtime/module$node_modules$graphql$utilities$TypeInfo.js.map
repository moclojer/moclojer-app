{
"version":3,
"file":"module$node_modules$graphql$utilities$TypeInfo.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/graphql/utilities/TypeInfo.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$utilities$TypeInfo\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _typeFromAST = require('./typeFromAST.js');\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nclass TypeInfo {\n  constructor(\n    schema,\n    /**\n     * Initial type may be provided in rare cases to facilitate traversals\n     *  beginning somewhere other than documents.\n     */\n    initialType,\n    /** @deprecated will be removed in 17.0.0 */\n    getFieldDefFn,\n  ) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef =\n      getFieldDefFn !== null && getFieldDefFn !== void 0\n        ? getFieldDefFn\n        : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET: {\n        const namedType = (0, _definition.getNamedType)(this.getType());\n\n        this._parentTypeStack.push(\n          (0, _definition.isCompositeType)(namedType) ? namedType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(fieldType) ? fieldType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n\n        this._typeStack.push(\n          (0, _definition.isObjectType)(rootType) ? rootType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST\n          ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST)\n          : (0, _definition.getNamedType)(this.getType());\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(outputType) ? outputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.VARIABLE_DEFINITION: {\n        const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputType) ? inputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ARGUMENT: {\n        var _this$getDirective;\n\n        let argDef;\n        let argType;\n        const fieldOrDirective =\n          (_this$getDirective = this.getDirective()) !== null &&\n          _this$getDirective !== void 0\n            ? _this$getDirective\n            : this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find(\n            (arg) => arg.name === node.name.value,\n          );\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(argType) ? argType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.LIST: {\n        const listType = (0, _definition.getNullableType)(this.getInputType());\n        const itemType = (0, _definition.isListType)(listType)\n          ? listType.ofType\n          : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(itemType) ? itemType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.OBJECT_FIELD: {\n        const objectType = (0, _definition.getNamedType)(this.getInputType());\n        let inputFieldType;\n        let inputField;\n\n        if ((0, _definition.isInputObjectType)(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(\n          inputField ? inputField.defaultValue : undefined,\n        );\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputFieldType)\n            ? inputFieldType\n            : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ENUM: {\n        const enumType = (0, _definition.getNamedType)(this.getInputType());\n        let enumValue;\n\n        if ((0, _definition.isEnumType)(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n      }\n\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n    }\n  }\n}\n\nexports.TypeInfo = TypeInfo;\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (\n    name === _introspection.SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeNameMetaFieldDef.name &&\n    (0, _definition.isCompositeType)(parentType)\n  ) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if (\n    (0, _definition.isObjectType)(parentType) ||\n    (0, _definition.isInterfaceType)(parentType)\n  ) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(...args) {\n      const node = args[0];\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    },\n  };\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getFieldDef","schema","parentType","fieldNode","name","value","_introspection","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","_definition","isCompositeType","isObjectType","isInterfaceType","getFields","Object","defineProperty","TypeInfo","visitWithTypeInfo","typeInfo","visitor","enter","args","node","fn","_visitor","getEnterLeaveForKind","kind","result","apply","undefined","leave","_ast","isNode","_kinds","_typeFromAST","constructor","initialType","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_enumValue","_argument","_directive","_getFieldDef","isInputType","push","isOutputType","Symbol","toStringTag","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","Kind","SELECTION_SET","namedType","getNamedType","FIELD","fieldDef","fieldType","type","DIRECTIVE","OPERATION_DEFINITION","rootType","getRootType","operation","INLINE_FRAGMENT","FRAGMENT_DEFINITION","outputType","typeConditionAST","typeCondition","typeFromAST","VARIABLE_DEFINITION","inputType","ARGUMENT","argDef","argType","fieldOrDirective","_this$getDirective","find","arg","defaultValue","LIST","listType","getNullableType","itemType","isListType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","isInputObjectType","ENUM","enumType","enumValue","isEnumType","getValue","pop"]
}
