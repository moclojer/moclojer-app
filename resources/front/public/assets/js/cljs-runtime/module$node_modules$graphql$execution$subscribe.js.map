{
"version":3,
"file":"module$node_modules$graphql$execution$subscribe.js",
"lineCount":7,
"mappings":"AAAAA,cAAA,CAAA,+CAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA4H5GC,cAAeA,wBAAuB,CAAC,GAAGC,OAAJ,CAAa,CA/CnB,CAC9B,MAAMC,SA+CwBD,OA/Cb,CAAK,CAAL,CAGf,QAAA,CADEC,QAAJ,EAAgB,UAAhB,EAA8BA,SAA9B,CACSA,QADT,CAIO,CACLC,OAAQD,QADH,CAGLE,SAsC4BH,OAtClB,CAAK,CAAL,CAHL,CAILI,UAqC4BJ,OArCjB,CAAK,CAAL,CAJN,CAKLK,aAoC4BL,OApCd,CAAK,CAAL,CALT,CAMLM,eAmC4BN,OAnCZ,CAAK,CAAL,CANX,CAOLO,cAkC4BP,OAlCb,CAAK,CAAL,CAPV,CAQLQ,uBAiC4BR,OAjCJ,CAAK,CAAL,CARnB,CAPuB,CAiD9B,MAAM,CAAEE,MAAF,CAAUC,QAAV,CAAoBG,cAApB,CAAA,CADOG,OAIb,IAAIC,QAASC,CAAAA,6BAAb,EAA4CT,MAA5C,CAAoDC,QAApD;AAA8DG,cAA9D,CAGMM,QAAAA,CAAa,GAAIF,QAASG,CAAAA,qBAAb,EAPNJ,OAOM,CAEnB,IAAI,EAAE,QAAF,EAAcG,QAAd,CAAJ,CACE,MAAO,CACLE,OAAQF,OADH,CAKT,IAAI,CACF,MAAMG,YAAc,MAAMC,mBAAA,CAAoBJ,OAApB,CAE1B,IAAI,CAAC,GAAIK,gBAAiBC,CAAAA,eAArB,EAAsCH,WAAtC,CAAL,CACE,KAAUI,MAAJ,CACJ,iDADI,CAED,aAAY,GAAIC,QAASC,CAAAA,OAAb,EAAsBN,WAAtB,CAAZ,GAFC,CAAN,CAMF,MAAOA,YAVL,CAWF,MAAOO,KAAP,CAAc,CAGd,GAAIA,KAAJ,WAAqBC,cAAcC,CAAAA,YAAnC,CACE,MAAO,CACLV,OAAQ,CAACQ,KAAD,CADH,CAKT,MAAMA,MAAN,CATc,CA3BiC,CAwCnDN,cAAeA,oBAAmB,CAACJ,UAAD,CAAa,CAC7C,MAAM,CAAEV,MAAF;AAAUuB,SAAV,CAAqBC,SAArB,CAAgCpB,cAAhC,CAAgDF,SAAhD,CAAA,CACJQ,UACF,KAAMe,SAAWzB,MAAO0B,CAAAA,mBAAP,EAEjB,IAAgB,IAAhB,EAAID,QAAJ,CACE,KAAM,KAAIJ,aAAcC,CAAAA,YAAlB,CACJ,6DADI,CAEJ,CACEK,MAAOH,SADT,CAFI,CAAN,CAQF,IAAMI,WAAa,GAAIC,cAAeC,CAAAA,aAAnB,EACjB9B,MADiB,CAEjBuB,SAFiB,CAGjBnB,cAHiB,CAIjBqB,QAJiB,CAKjBD,SAAUO,CAAAA,YALO,CAOnB,OAAM,CAACC,YAAD,CAAeC,UAAf,CAAA,CAA6B,CAAC,GAAGL,UAAWM,CAAAA,OAAX,EAAJ,CAAA,CAA0B,CAA1B,CAC7BC,WAAAA,CAAW,GAAI3B,QAAS4B,CAAAA,WAAb,EAA0BpC,MAA1B,CAAkCyB,QAAlC,CAA4CQ,UAAA,CAAW,CAAX,CAA5C,CAEjB,IAAI,CAACE,UAAL,CAEE,KAAM,KAAId,aAAcC,CAAAA,YAAlB,CACH,2BAFeW,UAAA,CAAW,CAAX,CAAcI,CAAAA,IAAKC,CAAAA,KAElC,mBADG;AAEJ,CACEX,MAAOM,UADT,CAFI,CAAN,CAQF,MAAMM,KAAO,GAAIC,KAAMC,CAAAA,OAAV,EAAmBC,IAAAA,EAAnB,CAA8BV,YAA9B,CAA4CP,QAASY,CAAAA,IAArD,CACPM,SAAAA,CAAO,GAAInC,QAASoC,CAAAA,gBAAb,EACXlC,UADW,CAEXyB,UAFW,CAGXF,UAHW,CAIXR,QAJW,CAKXc,IALW,CAQb,IAAI,CACF,IAAIM,mBAMJ,OAAMtC,KAAO,GAAIuC,OAAQC,CAAAA,iBAAZ,EACXZ,UADW,CAEXF,UAAA,CAAW,CAAX,CAFW,CAGX7B,cAHW,CAAb,CAQMD,aAAeO,UAAWP,CAAAA,YARhC,CAgBMU,YAAc,MAAM,CAJuB,IAA/CmC,IAACH,mBAADG,CAAuBb,UAASc,CAAAA,SAAhCD,GACwB,IAAK,EAD7BA,GACAH,mBADAG,CAEIH,mBAFJG,CAGItC,UAAWJ,CAAAA,sBACS,EAAUJ,SAAV,CAAqBK,IAArB,CAA2BJ,YAA3B,CAAyCwC,QAAzC,CAE1B;GAAI9B,WAAJ,WAA2BI,MAA3B,CACE,KAAMJ,YAAN,CAGF,MAAOA,YA7BL,CA8BF,MAAOO,KAAP,CAAc,CACd,KAAM,GAAI8B,aAAcC,CAAAA,YAAlB,EACJ/B,KADI,CAEJa,UAFI,CAGJ,GAAIO,KAAMY,CAAAA,WAAV,EAAuBb,IAAvB,CAHI,CAAN,CADc,CAzE6B,CAjK/Cc,MAAOC,CAAAA,cAAP,CAAsB1D,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C0C,MAAO,CAAA,CADoC,CAA7C,CAGA1C,QAAQC,CAAAA,uBAAR,CAAkCA,uBAClCD,QAAQqD,CAAAA,SAAR,CA2CAA,cAAwB,CAAC1C,IAAD,CAAO,CAEV,CAAnB,CAAAgD,SAAUC,CAAAA,MAAV,EACE,GAAIC,UAAWC,CAAAA,SAAf,EACE,CAAA,CADF,CAEE,qGAFF,CAIF,OAAMC,eAAiB,MAAM9D,uBAAA,CAAwBU,IAAxB,CAE7B;MAAK,GAAIQ,gBAAiBC,CAAAA,eAArB,EAAsC2C,cAAtC,CAAL,CAYO,GAAIC,iBAAkBC,CAAAA,gBAAtB,EACLF,cADK,CAHsBG,OAADC,EAC1B,GAAIvD,QAASwD,CAAAA,OAAb,EAAsB,CAAE,GAAGzD,IAAL,CAAWL,UAAW4D,OAAtB,CAAtB,CAEK,CAZP,CACSH,cAVoB,CAzC/B,KAAIF,WAAa/D,OAAA,CAAQ,+CAAR,CAAjB,CAEIwB,SAAWxB,OAAA,CAAQ,6CAAR,CAFf,CAIIqB,iBAAmBrB,OAAA,CAAQ,qDAAR,CAJvB,CAMI8C,MAAQ9C,OAAA,CAAQ,0CAAR,CANZ,CAQI2B,cAAgB3B,OAAA,CAAQ,gDAAR,CARpB;AAUIwD,cAAgBxD,OAAA,CAAQ,gDAAR,CAVpB,CAYImC,eAAiBnC,OAAA,CAAQ,qDAAR,CAZrB,CAcIc,SAAWd,OAAA,CAAQ,+CAAR,CAdf,CAgBIkE,kBAAoBlE,OAAA,CAAQ,wDAAR,CAhBxB,CAkBIoD,QAAUpD,OAAA,CAAQ,8CAAR,CA3B8F;",
"sources":["node_modules/graphql/execution/subscribe.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$execution$subscribe\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.createSourceEventStream = createSourceEventStream;\nexports.subscribe = subscribe;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _isAsyncIterable = require('../jsutils/isAsyncIterable.js');\n\nvar _Path = require('../jsutils/Path.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _locatedError = require('../error/locatedError.js');\n\nvar _collectFields = require('./collectFields.js');\n\nvar _execute = require('./execute.js');\n\nvar _mapAsyncIterator = require('./mapAsyncIterator.js');\n\nvar _values = require('./values.js');\n\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\nasync function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    (0, _devAssert.devAssert)(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    (0, _execute.execute)({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return (0, _mapAsyncIterator.mapAsyncIterator)(\n    resultOrStream,\n    mapSourceToResponse,\n  );\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nasync function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = (0, _execute.buildExecutionContext)(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${(0, _inspect.inspect)(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof _GraphQLError.GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new _GraphQLError.GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = (0, _collectFields.collectFields)(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new _GraphQLError.GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = (0, _Path.addPath)(undefined, responseName, rootType.name);\n  const info = (0, _execute.buildResolveInfo)(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = (0, _values.getArgumentValues)(\n      fieldDef,\n      fieldNodes[0],\n      variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw (0, _locatedError.locatedError)(\n      error,\n      fieldNodes,\n      (0, _Path.pathToArray)(path),\n    );\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","createSourceEventStream","rawArgs","firstArg","schema","document","rootValue","contextValue","variableValues","operationName","subscribeFieldResolver","args","_execute","assertValidExecutionArguments","exeContext","buildExecutionContext","errors","eventStream","executeSubscription","_isAsyncIterable","isAsyncIterable","Error","_inspect","inspect","error","_GraphQLError","GraphQLError","fragments","operation","rootType","getSubscriptionType","nodes","rootFields","_collectFields","collectFields","selectionSet","responseName","fieldNodes","entries","fieldDef","getFieldDef","name","value","path","_Path","addPath","undefined","info","buildResolveInfo","_fieldDef$subscribe","_values","getArgumentValues","resolveFn","subscribe","_locatedError","locatedError","pathToArray","Object","defineProperty","arguments","length","_devAssert","devAssert","resultOrStream","_mapAsyncIterator","mapAsyncIterator","payload","mapSourceToResponse","execute"]
}
