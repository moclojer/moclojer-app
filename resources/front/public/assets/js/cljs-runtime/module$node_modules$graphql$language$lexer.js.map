{
"version":3,
"file":"module$node_modules$graphql$language$lexer.js",
"lineCount":23,
"mappings":"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",
"sources":["node_modules/graphql/language/lexer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$language$lexer\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.Lexer = void 0;\nexports.isPunctuatorTokenKind = isPunctuatorTokenKind;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _blockString = require('./blockString.js');\n\nvar _characterClasses = require('./characterClasses.js');\n\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nclass Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new _ast.Token(\n      _tokenKind.TokenKind.SOF,\n      0,\n      0,\n      0,\n      0,\n    );\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== _tokenKind.TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === _tokenKind.TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexports.Lexer = Lexer;\n\nfunction isPunctuatorTokenKind(kind) {\n  return (\n    kind === _tokenKind.TokenKind.BANG ||\n    kind === _tokenKind.TokenKind.DOLLAR ||\n    kind === _tokenKind.TokenKind.AMP ||\n    kind === _tokenKind.TokenKind.PAREN_L ||\n    kind === _tokenKind.TokenKind.PAREN_R ||\n    kind === _tokenKind.TokenKind.SPREAD ||\n    kind === _tokenKind.TokenKind.COLON ||\n    kind === _tokenKind.TokenKind.EQUALS ||\n    kind === _tokenKind.TokenKind.AT ||\n    kind === _tokenKind.TokenKind.BRACKET_L ||\n    kind === _tokenKind.TokenKind.BRACKET_R ||\n    kind === _tokenKind.TokenKind.BRACE_L ||\n    kind === _tokenKind.TokenKind.PIPE ||\n    kind === _tokenKind.TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return _tokenKind.TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new _ast.Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BANG,\n          position,\n          position + 1,\n        );\n\n      case 0x0024:\n        // $\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.DOLLAR,\n          position,\n          position + 1,\n        );\n\n      case 0x0026:\n        // &\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.AMP,\n          position,\n          position + 1,\n        );\n\n      case 0x0028:\n        // (\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PAREN_L,\n          position,\n          position + 1,\n        );\n\n      case 0x0029:\n        // )\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PAREN_R,\n          position,\n          position + 1,\n        );\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(\n            lexer,\n            _tokenKind.TokenKind.SPREAD,\n            position,\n            position + 3,\n          );\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.COLON,\n          position,\n          position + 1,\n        );\n\n      case 0x003d:\n        // =\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.EQUALS,\n          position,\n          position + 1,\n        );\n\n      case 0x0040:\n        // @\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.AT,\n          position,\n          position + 1,\n        );\n\n      case 0x005b:\n        // [\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACKET_L,\n          position,\n          position + 1,\n        );\n\n      case 0x005d:\n        // ]\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACKET_R,\n          position,\n          position + 1,\n        );\n\n      case 0x007b:\n        // {\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACE_L,\n          position,\n          position + 1,\n        );\n\n      case 0x007c:\n        // |\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PIPE,\n          position,\n          position + 1,\n        );\n\n      case 0x007d:\n        // }\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACE_R,\n          position,\n          position + 1,\n        );\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if ((0, _characterClasses.isDigit)(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if ((0, _characterClasses.isNameStart)(code)) {\n      return readName(lexer, position);\n    }\n\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    _tokenKind.TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if ((0, _characterClasses.isDigit)(code)) {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || (0, _characterClasses.isNameStart)(code)) {\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!(0, _characterClasses.isDigit)(firstCode)) {\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(\n        lexer,\n        _tokenKind.TokenKind.STRING,\n        start,\n        position + 1,\n        value,\n      );\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    'Unterminated string.',\n  );\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        _tokenKind.TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        (0, _blockString.dedentBlockStringLines)(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    'Unterminated string.',\n  );\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if ((0, _characterClasses.isNameContinue)(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    _tokenKind.TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","isUnicodeScalarValue","code","isSupplementaryCodePoint","body","location","charCodeAt","printCodePointAt","lexer","source","codePointAt","undefined","_tokenKind","TokenKind","EOF","char","String","fromCodePoint","toString","toUpperCase","padStart","createToken","kind","start","end","value","_ast","Token","line","lineStart","readNextToken","bodyLength","length","position","COMMENT","slice","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","chunkStart","currentLine","blockLines","push","token","BLOCK_STRING","_blockString","dedentBlockStringLines","join","_syntaxError","syntaxError","STRING","point","size","readHexDigit","read16BitHexCode","trailingCode","escape","_characterClasses","isDigit","isFloat","readDigits","isNameStart","FLOAT","INT","isNameContinue","NAME","firstCode","readEscapedCharacter","Object","defineProperty","Lexer","isPunctuatorTokenKind","constructor","startOfFileToken","SOF","lastToken","Symbol","toStringTag","advance","lookahead","next","nextToken","prev"]
}
