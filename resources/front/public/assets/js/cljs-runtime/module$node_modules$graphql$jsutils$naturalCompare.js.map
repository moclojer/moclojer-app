{
"version":3,
"file":"module$node_modules$graphql$jsutils$naturalCompare.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAmE/GC,QAASA,QAAO,CAACC,IAAD,CAAO,CACrB,MAAO,CAACC,KAAA,CAAMD,IAAN,CAAR,EAJcE,EAId,EAAkCF,IAAlC,EAHcG,EAGd,EAA0CH,IADrB,CAhEvBI,MAAOC,CAAAA,cAAP,CAAsBP,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CQ,MAAO,CAAA,CADoC,CAA7C,CAGAR,QAAQS,CAAAA,cAAR,CASAA,QAAuB,CAACC,IAAD,CAAOC,IAAP,CAAa,CAClC,IAAIC,OAAS,CAAb,CACIC,OAAS,CAEb,KAAA,CAAOD,MAAP,CAAgBF,IAAKI,CAAAA,MAArB,EAA+BD,MAA/B,CAAwCF,IAAKG,CAAAA,MAA7C,CAAA,CAAqD,CACnD,IAAIC,MAAQL,IAAKM,CAAAA,UAAL,CAAgBJ,MAAhB,CACZ,KAAIK,MAAQN,IAAKK,CAAAA,UAAL,CAAgBH,MAAhB,CAEZ,IAAIZ,OAAA,CAAQc,KAAR,CAAJ,EAAsBd,OAAA,CAAQgB,KAAR,CAAtB,CAAsC,CACpC,IAAIC,KAAO,CAEX,GACE,EAAEN,MAEF,CADAM,IACA,CADc,EACd,CADOA,IACP,CADmBH,KACnB,CAmCQX,EAnCR,CAAAW,KAAA,CAAQL,IAAKM,CAAAA,UAAL,CAAgBJ,MAAhB,CAHV;MAISX,OAAA,CAAQc,KAAR,CAJT,EAIkC,CAJlC,CAI2BG,IAJ3B,CAMIC,MAAAA,CAAO,CAEX,GACE,EAAEN,MAEF,CADAM,KACA,CADc,EACd,CADOA,KACP,CADmBF,KACnB,CA2BQb,EA3BR,CAAAa,KAAA,CAAQN,IAAKK,CAAAA,UAAL,CAAgBH,MAAhB,CAHV,OAISZ,OAAA,CAAQgB,KAAR,CAJT,EAIkC,CAJlC,CAI2BE,KAJ3B,CAMA,IAAID,IAAJ,CAAWC,KAAX,CACE,MAAO,CAAC,CAGV,IAAID,IAAJ,CAAWC,KAAX,CACE,MAAO,EAtB2B,CAAtC,IAwBO,CACL,GAAIJ,KAAJ,CAAYE,KAAZ,CACE,MAAO,CAAC,CAGV,IAAIF,KAAJ,CAAYE,KAAZ,CACE,MAAO,EAGT,GAAEL,MACF,GAAEC,MAVG,CA5B4C,CA0CrD,MAAOH,KAAKI,CAAAA,MAAZ,CAAqBH,IAAKG,CAAAA,MA9CQ,CAf2E;",
"sources":["node_modules/graphql/jsutils/naturalCompare.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$jsutils$naturalCompare\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.naturalCompare = naturalCompare;\n\n/**\n * Returns a number indicating whether a reference string comes before, or after,\n * or is the same as the given string in natural sort order.\n *\n * See: https://en.wikipedia.org/wiki/Natural_sort_order\n *\n */\nfunction naturalCompare(aStr, bStr) {\n  let aIndex = 0;\n  let bIndex = 0;\n\n  while (aIndex < aStr.length && bIndex < bStr.length) {\n    let aChar = aStr.charCodeAt(aIndex);\n    let bChar = bStr.charCodeAt(bIndex);\n\n    if (isDigit(aChar) && isDigit(bChar)) {\n      let aNum = 0;\n\n      do {\n        ++aIndex;\n        aNum = aNum * 10 + aChar - DIGIT_0;\n        aChar = aStr.charCodeAt(aIndex);\n      } while (isDigit(aChar) && aNum > 0);\n\n      let bNum = 0;\n\n      do {\n        ++bIndex;\n        bNum = bNum * 10 + bChar - DIGIT_0;\n        bChar = bStr.charCodeAt(bIndex);\n      } while (isDigit(bChar) && bNum > 0);\n\n      if (aNum < bNum) {\n        return -1;\n      }\n\n      if (aNum > bNum) {\n        return 1;\n      }\n    } else {\n      if (aChar < bChar) {\n        return -1;\n      }\n\n      if (aChar > bChar) {\n        return 1;\n      }\n\n      ++aIndex;\n      ++bIndex;\n    }\n  }\n\n  return aStr.length - bStr.length;\n}\n\nconst DIGIT_0 = 48;\nconst DIGIT_9 = 57;\n\nfunction isDigit(code) {\n  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","isDigit","code","isNaN","DIGIT_0","DIGIT_9","Object","defineProperty","value","naturalCompare","aStr","bStr","aIndex","bIndex","length","aChar","charCodeAt","bChar","aNum","bNum"]
}
