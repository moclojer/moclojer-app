shadow$provide.module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$prepare_destination=function(global,require,module,exports){function compileNonPath(value,params){if(!value.includes(":"))return value;for(const key of Object.keys(params))value.includes(`:${key}`)&&(value=value.replace(new RegExp(`:${key}\\*`,"g"),`:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\?`,"g"),`:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\+`,"g"),`:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\w)`,
"g"),`--ESCAPED_PARAM_COLON${key}`));value=value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g,"\\$1").replace(/--ESCAPED_PARAM_PLUS/g,"+").replace(/--ESCAPED_PARAM_COLON/g,":").replace(/--ESCAPED_PARAM_QUESTION/g,"?").replace(/--ESCAPED_PARAM_ASTERISKS/g,"*");return(0,_pathToRegexp).compile(`/${value}`,{validate:!1})(params).slice(1)}function getSafeParamName(paramName){let newParamName="";for(let i=0;i<paramName.length;i++){const charCode=paramName.charCodeAt(i);if(64<charCode&&91>charCode||96<charCode&&
123>charCode)newParamName+=paramName[i]}return newParamName}function escapeSegment(str,segmentName){return str.replace(new RegExp(`:${(0,_escapeRegexp).escapeStringRegexp(segmentName)}`,"g"),`__ESC_COLON_${segmentName}`)}function unescapeSegments(str){return str.replace(/__ESC_COLON_/gi,":")}Object.defineProperty(exports,"__esModule",{value:!0});exports.matchHas=function(req,has,query){const params={};return has.every(hasItem=>{var key=hasItem.key;switch(hasItem.type){case "header":key=key.toLowerCase();
var value=req.headers[key];break;case "cookie":value=req.cookies[hasItem.key];break;case "query":value=query[key];break;case "host":({host:value}=(null==req?void 0:req.headers)||{}),value=null==value?void 0:value.split(":")[0].toLowerCase()}if(!hasItem.value&&value)return params[getSafeParamName(key)]=value,!0;if(value){key=new RegExp(`^${hasItem.value}$`);const matches=Array.isArray(value)?value.slice(-1)[0].match(key):value.match(key);if(matches)return Array.isArray(matches)&&(matches.groups?Object.keys(matches.groups).forEach(groupKey=>
{params[groupKey]=matches.groups[groupKey]}):"host"===hasItem.type&&matches[0]&&(params.host=matches[0])),!0}return!1})?params:!1};exports.compileNonPath=compileNonPath;exports.prepareDestination=function(args){const query=Object.assign({},args.query);delete query.__nextLocale;delete query.__nextDefaultLocale;delete query.__nextDataReq;var escapedDestination=args.destination;for(var param of Object.keys(_extends({},args.params,query)))escapedDestination=escapeSegment(escapedDestination,param);escapedDestination=
(0,_parseUrl).parseUrl(escapedDestination);param=escapedDestination.query;var destPath=unescapeSegments(`${escapedDestination.pathname}${escapedDestination.hash||""}`),destHostname=unescapeSegments(escapedDestination.hostname||""),destPathParamKeys=[];const destHostnameParamKeys=[];(0,_pathToRegexp).pathToRegexp(destPath,destPathParamKeys);(0,_pathToRegexp).pathToRegexp(destHostname,destHostnameParamKeys);const destParams=[];destPathParamKeys.forEach(key=>destParams.push(key.name));destHostnameParamKeys.forEach(key=>
destParams.push(key.name));destPath=(0,_pathToRegexp).compile(destPath,{validate:!1});destHostname=(0,_pathToRegexp).compile(destHostname,{validate:!1});for(const [key1,strOrArray]of Object.entries(param))Array.isArray(strOrArray)?param[key1]=strOrArray.map(value=>compileNonPath(unescapeSegments(value),args.params)):param[key1]=compileNonPath(unescapeSegments(strOrArray),args.params);destPathParamKeys=Object.keys(args.params).filter(name=>"nextInternalLocale"!==name);if(args.appendParamsToQuery&&
!destPathParamKeys.some(key=>destParams.includes(key)))for(const key of destPathParamKeys)key in param||(param[key]=args.params[key]);let newUrl;try{newUrl=destPath(args.params);const [pathname,hash]=newUrl.split("#");escapedDestination.hostname=destHostname(args.params);escapedDestination.pathname=pathname;escapedDestination.hash=`${hash?"#":""}${hash||""}`;delete escapedDestination.search}catch(err){if(err.message.match(/Expected .*? to not repeat, but got an array/))throw Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match");
throw err;}escapedDestination.query=_extends({},query,escapedDestination.query);return{newUrl,destQuery:param,parsedDestination:escapedDestination}};var _extends=require("module$node_modules$moclojer_components$node_modules$$swc$helpers$lib$_extends").default,_pathToRegexp=require("module$node_modules$moclojer_components$node_modules$next$dist$compiled$path_to_regexp$index"),_escapeRegexp=require("module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$escape_regexp"),_parseUrl=
require("module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$parse_url")}
//# sourceMappingURL=module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$prepare_destination.js.map
