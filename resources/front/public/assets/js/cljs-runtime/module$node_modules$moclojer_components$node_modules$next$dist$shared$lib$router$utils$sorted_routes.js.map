{
"version":3,
"file":"module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$sorted_routes.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/moclojer-components/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$moclojer_components$node_modules$next$dist$shared$lib$router$utils$sorted_routes\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split('/').filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix = '/') {\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n        }\n        if (!this.placeholder) {\n            const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(`Catch-all must be the last part of the URL.`);\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith('...')) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n                throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n            }\n            if (segmentName.startsWith('.')) {\n                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n                    }\n                    if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n                        throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = '[[...]]';\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = '[...]';\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[]';\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n}\n\n//# sourceMappingURL=sorted-routes.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","getSortedRoutes","normalizedPages","root","UrlNode","forEach","pagePath","insert","smoosh","urlPath","_insert","split","filter","Boolean","_smoosh","prefix","childrenPaths","children","keys","sort","slugName","splice","indexOf","restSlugName","optionalRestSlugName","routes","map","c","get","reduce","prev","curr","push","placeholder","r","slice","Error","unshift","urlPaths","slugNames","isCatchAll","length","nextSegment","startsWith","endsWith","segmentName","isOptional","substring","handleSlug","previousSlug","nextSlug","slug","replace","has","set","constructor","Map"]
}
