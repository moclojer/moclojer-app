{
"version":3,
"file":"module$node_modules$graphql$validation$rules$FragmentsOnCompositeTypesRule.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,0EAAA,CAA+F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGvIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,6BAAR,CAmBAA,QAAsC,CAACC,OAAD,CAAU,CAC9C,MAAO,CACLC,cAAc,CAACC,IAAD,CAAO,CAGnB,GAFMC,IAEN,CAFsBD,IAAKC,CAAAA,aAE3B,CAAmB,CACjB,IAAMC,KAAO,GAAIC,YAAaC,CAAAA,WAAjB,EACXN,OAAQO,CAAAA,SAAR,EADW,CAEXJ,IAFW,CAKTC,KAAJ,EAAY,CAAC,GAAII,WAAYC,CAAAA,eAAhB,EAAiCL,IAAjC,CAAb,GACQM,IACN,CADgB,GAAIC,QAASC,CAAAA,KAAb,EAAoBT,IAApB,CAChB,CAAAH,OAAQa,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,oDAAmDL,IAAnD,IADH;AAEE,CACEM,MAAOb,IADT,CAFF,CADF,CAFF,CANiB,CAHA,CADhB,CAwBLc,kBAAkB,CAACf,IAAD,CAAO,CACvB,IAAME,KAAO,GAAIC,YAAaC,CAAAA,WAAjB,EACXN,OAAQO,CAAAA,SAAR,EADW,CAEXL,IAAKC,CAAAA,aAFM,CAKTC,KAAJ,EAAY,CAAC,GAAII,WAAYC,CAAAA,eAAhB,EAAiCL,IAAjC,CAAb,GACQM,IACN,CADgB,GAAIC,QAASC,CAAAA,KAAb,EAAoBV,IAAKC,CAAAA,aAAzB,CAChB,CAAAH,OAAQa,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,aAAYb,IAAKgB,CAAAA,IAAKpB,CAAAA,KAAtB,6CAAwEY,IAAxE,IADH,CAEE,CACEM,MAAOd,IAAKC,CAAAA,aADd,CAFF,CADF,CAFF,CANuB,CAxBpB,CADuC,CAjBhD,KAAIW,cAAgBrB,OAAA,CAAQ,gDAAR,CAApB,CAEIkB,SAAWlB,OAAA,CAAQ,8CAAR,CAFf;AAIIe,YAAcf,OAAA,CAAQ,6CAAR,CAJlB,CAMIY,aAAeZ,OAAA,CAAQ,mDAAR,CAdoH;",
"sources":["node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$FragmentsOnCompositeTypesRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = (0, _typeFromAST.typeFromAST)(\n          context.getSchema(),\n          typeCondition,\n        );\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          const typeStr = (0, _printer.print)(typeCondition);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = (0, _typeFromAST.typeFromAST)(\n        context.getSchema(),\n        node.typeCondition,\n      );\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        const typeStr = (0, _printer.print)(node.typeCondition);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","FragmentsOnCompositeTypesRule","context","InlineFragment","node","typeCondition","type","_typeFromAST","typeFromAST","getSchema","_definition","isCompositeType","typeStr","_printer","print","reportError","_GraphQLError","GraphQLError","nodes","FragmentDefinition","name"]
}
