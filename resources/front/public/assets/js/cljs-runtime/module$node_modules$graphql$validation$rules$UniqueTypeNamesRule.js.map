{
"version":3,
"file":"module$node_modules$graphql$validation$rules$UniqueTypeNamesRule.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,gEAAA,CAAqF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG7HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,mBAAR,CASAA,QAA4B,CAACC,OAAD,CAAU,CAYpCC,QAASA,cAAa,CAACC,IAAD,CAAO,CAC3B,MAAMC,SAAWD,IAAKE,CAAAA,IAAKN,CAAAA,KAE3B,IAAe,IAAf,GAAIO,MAAJ,EAAkC,IAAK,EAAvC,GAAuBA,MAAvB,EAA4CA,MAAOC,CAAAA,OAAP,CAAeH,QAAf,CAA5C,CACEH,OAAQO,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,SAAQN,QAAR,oFADH,CAEE,CACEO,MAAOR,IAAKE,CAAAA,IADd,CAFF,CADF,CADF;IAyBA,OAbIO,eAAA,CAAeR,QAAf,CAAJ,CACEH,OAAQO,CAAAA,WAAR,CACE,IAAIC,aAAcC,CAAAA,YAAlB,CACG,qCAAoCN,QAApC,IADH,CAEE,CACEO,MAAO,CAACC,cAAA,CAAeR,QAAf,CAAD,CAA2BD,IAAKE,CAAAA,IAAhC,CADT,CAFF,CADF,CADF,CAUEO,cAAA,CAAeR,QAAf,CAVF,CAU6BD,IAAKE,CAAAA,IAG3B,CAAA,CAAA,CA5BoB,CAX7B,MAAMO,eAAiBf,MAAOgB,CAAAA,MAAP,CAAc,IAAd,CAAvB,CACMP,OAASL,OAAQa,CAAAA,SAAR,EACf,OAAO,CACLC,qBAAsBb,aADjB,CAELc,qBAAsBd,aAFjB,CAGLe,wBAAyBf,aAHpB,CAILgB,oBAAqBhB,aAJhB,CAKLiB,mBAAoBjB,aALf,CAMLkB,0BAA2BlB,aANtB,CAH6B,CAPtC;IAAIO,cAAgBf,OAAA,CAAQ,gDAAR,CARyG;",
"sources":["node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$UniqueTypeNamesRule\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueTypeNamesRule = UniqueTypeNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nfunction UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `There can be only one type named \"${typeName}\".`,\n          {\n            nodes: [knownTypeNames[typeName], node.name],\n          },\n        ),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","UniqueTypeNamesRule","context","checkTypeName","node","typeName","name","schema","getType","reportError","_GraphQLError","GraphQLError","nodes","knownTypeNames","create","getSchema","ScalarTypeDefinition","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition"]
}
