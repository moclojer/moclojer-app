shadow$provide.module$node_modules$graphql$validation$rules$FragmentsOnCompositeTypesRule=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.FragmentsOnCompositeTypesRule=function(context){return{InlineFragment(node){if(node=node.typeCondition){var type=(0,_typeFromAST.typeFromAST)(context.getSchema(),node);type&&!(0,_definition.isCompositeType)(type)&&(type=(0,_printer.print)(node),context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${type}".`,
{nodes:node})))}},FragmentDefinition(node){var type=(0,_typeFromAST.typeFromAST)(context.getSchema(),node.typeCondition);type&&!(0,_definition.isCompositeType)(type)&&(type=(0,_printer.print)(node.typeCondition),context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${type}".`,{nodes:node.typeCondition})))}}};var _GraphQLError=require("module$node_modules$graphql$error$GraphQLError"),_printer=require("module$node_modules$graphql$language$printer"),
_definition=require("module$node_modules$graphql$type$definition"),_typeFromAST=require("module$node_modules$graphql$utilities$typeFromAST")}
//# sourceMappingURL=module$node_modules$graphql$validation$rules$FragmentsOnCompositeTypesRule.js.map
