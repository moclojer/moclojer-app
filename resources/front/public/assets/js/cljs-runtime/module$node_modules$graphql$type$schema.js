shadow$provide.module$node_modules$graphql$type$schema=function(global,require,module,exports){function isSchema(schema){return(0,_instanceOf.instanceOf)(schema,GraphQLSchema)}function collectReferencedTypes(type,typeSet){type=(0,_definition.getNamedType)(type);if(!typeSet.has(type))if(typeSet.add(type),(0,_definition.isUnionType)(type))for(const memberType of type.getTypes())collectReferencedTypes(memberType,typeSet);else if((0,_definition.isObjectType)(type)||(0,_definition.isInterfaceType)(type)){for(const interfaceType of type.getInterfaces())collectReferencedTypes(interfaceType,
typeSet);for(const field of Object.values(type.getFields())){collectReferencedTypes(field.type,typeSet);for(const arg of field.args)collectReferencedTypes(arg.type,typeSet)}}else if((0,_definition.isInputObjectType)(type))for(const field of Object.values(type.getFields()))collectReferencedTypes(field.type,typeSet);return typeSet}Object.defineProperty(exports,"__esModule",{value:!0});exports.GraphQLSchema=void 0;exports.assertSchema=function(schema){if(!isSchema(schema))throw Error(`Expected ${(0,_inspect.inspect)(schema)} to be a GraphQL schema.`);
return schema};exports.isSchema=isSchema;var _devAssert=require("module$node_modules$graphql$jsutils$devAssert"),_inspect=require("module$node_modules$graphql$jsutils$inspect"),_instanceOf=require("module$node_modules$graphql$jsutils$instanceOf"),_isObjectLike=require("module$node_modules$graphql$jsutils$isObjectLike"),_toObjMap=require("module$node_modules$graphql$jsutils$toObjMap"),_ast=require("module$node_modules$graphql$language$ast"),_definition=require("module$node_modules$graphql$type$definition"),
_directives=require("module$node_modules$graphql$type$directives"),_introspection=require("module$node_modules$graphql$type$introspection");class GraphQLSchema{constructor(config){var _config$extensionASTN,_config$directives;this.__validationErrors=!0===config.assumeValid?[]:void 0;(0,_isObjectLike.isObjectLike)(config)||(0,_devAssert.devAssert)(!1,"Must provide configuration object.");!config.types||Array.isArray(config.types)||(0,_devAssert.devAssert)(!1,`"types" must be Array if provided but got: ${(0,_inspect.inspect)(config.types)}.`);
!config.directives||Array.isArray(config.directives)||(0,_devAssert.devAssert)(!1,'"directives" must be Array if provided but got: '+`${(0,_inspect.inspect)(config.directives)}.`);this.description=config.description;this.extensions=(0,_toObjMap.toObjMap)(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=null!==(_config$extensionASTN=config.extensionASTNodes)&&void 0!==_config$extensionASTN?_config$extensionASTN:[];this._queryType=config.query;this._mutationType=config.mutation;
this._subscriptionType=config.subscription;this._directives=null!==(_config$directives=config.directives)&&void 0!==_config$directives?_config$directives:_directives.specifiedDirectives;_config$extensionASTN=new Set(config.types);if(null!=config.types)for(const type of config.types)_config$extensionASTN.delete(type),collectReferencedTypes(type,_config$extensionASTN);null!=this._queryType&&collectReferencedTypes(this._queryType,_config$extensionASTN);null!=this._mutationType&&collectReferencedTypes(this._mutationType,
_config$extensionASTN);null!=this._subscriptionType&&collectReferencedTypes(this._subscriptionType,_config$extensionASTN);for(const directive of this._directives)if((0,_directives.isDirective)(directive))for(const arg of directive.args)collectReferencedTypes(arg.type,_config$extensionASTN);collectReferencedTypes(_introspection.__Schema,_config$extensionASTN);this._typeMap=Object.create(null);this._subTypeMap=Object.create(null);this._implementationsMap=Object.create(null);for(const namedType of _config$extensionASTN)if(null!=
namedType){(config=namedType.name)||(0,_devAssert.devAssert)(!1,"One of the provided types for building the Schema is missing a name.");if(void 0!==this._typeMap[config])throw Error(`Schema must contain uniquely named types but contains multiple types named "${config}".`);this._typeMap[config]=namedType;if((0,_definition.isInterfaceType)(namedType))for(const iface of namedType.getInterfaces())(0,_definition.isInterfaceType)(iface)&&(config=this._implementationsMap[iface.name],void 0===config&&(config=
this._implementationsMap[iface.name]={objects:[],interfaces:[]}),config.interfaces.push(namedType));else if((0,_definition.isObjectType)(namedType))for(const iface of namedType.getInterfaces())(0,_definition.isInterfaceType)(iface)&&(config=this._implementationsMap[iface.name],void 0===config&&(config=this._implementationsMap[iface.name]={objects:[],interfaces:[]}),config.objects.push(namedType))}}get [Symbol.toStringTag](){return"GraphQLSchema"}getQueryType(){return this._queryType}getMutationType(){return this._mutationType}getSubscriptionType(){return this._subscriptionType}getRootType(operation){switch(operation){case _ast.OperationTypeNode.QUERY:return this.getQueryType();
case _ast.OperationTypeNode.MUTATION:return this.getMutationType();case _ast.OperationTypeNode.SUBSCRIPTION:return this.getSubscriptionType()}}getTypeMap(){return this._typeMap}getType(name){return this.getTypeMap()[name]}getPossibleTypes(abstractType){return(0,_definition.isUnionType)(abstractType)?abstractType.getTypes():this.getImplementations(abstractType).objects}getImplementations(interfaceType){interfaceType=this._implementationsMap[interfaceType.name];return null!==interfaceType&&void 0!==
interfaceType?interfaceType:{objects:[],interfaces:[]}}isSubType(abstractType,maybeSubType){let map=this._subTypeMap[abstractType.name];if(void 0===map){map=Object.create(null);if((0,_definition.isUnionType)(abstractType))for(var type$jscomp$0 of abstractType.getTypes())map[type$jscomp$0.name]=!0;else{type$jscomp$0=this.getImplementations(abstractType);for(const type of type$jscomp$0.objects)map[type.name]=!0;for(const type of type$jscomp$0.interfaces)map[type.name]=!0}this._subTypeMap[abstractType.name]=
map}return void 0!==map[maybeSubType.name]}getDirectives(){return this._directives}getDirective(name){return this.getDirectives().find(directive=>directive.name===name)}toConfig(){return{description:this.description,query:this.getQueryType(),mutation:this.getMutationType(),subscription:this.getSubscriptionType(),types:Object.values(this.getTypeMap()),directives:this.getDirectives(),extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes,assumeValid:void 0!==this.__validationErrors}}}
exports.GraphQLSchema=GraphQLSchema}
//# sourceMappingURL=module$node_modules$graphql$type$schema.js.map
