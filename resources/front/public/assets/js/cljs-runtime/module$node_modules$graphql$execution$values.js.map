{
"version":3,
"file":"module$node_modules$graphql$execution$values.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/graphql/execution/values.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$execution$values\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\nexports.getVariableValues = getVariableValues;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printPathArray = require('../jsutils/printPathArray.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _coerceInputValue = require('../utilities/coerceInputValue.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _valueFromAST = require('../utilities/valueFromAST.js');\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new _GraphQLError.GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = (0, _printer.print)(varDefNode.type);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(\n          varDefNode.defaultValue,\n          varType,\n        );\n      } else if ((0, _definition.isNonNullType)(varType)) {\n        const varTypeStr = (0, _inspect.inspect)(varType);\n        onError(\n          new _GraphQLError.GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && (0, _definition.isNonNullType)(varType)) {\n      const varTypeStr = (0, _inspect.inspect)(varType);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` +\n          (0, _inspect.inspect)(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${(0, _printPathArray.printPathArray)(\n            path,\n          )}\"`;\n        }\n\n        onError(\n          new _GraphQLError.GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error.originalError,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = (0, _keyMap.keyMap)(\n    argumentNodes,\n    (arg) => arg.name.value,\n  );\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if ((0, _definition.isNonNullType)(argType)) {\n        throw new _GraphQLError.GraphQLError(\n          `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n            argType,\n          )}\" ` + 'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === _kinds.Kind.NULL;\n\n    if (valueNode.kind === _kinds.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if ((0, _definition.isNonNullType)(argType)) {\n          throw new _GraphQLError.GraphQLError(\n            `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n              argType,\n            )}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && (0, _definition.isNonNullType)(argType)) {\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" of non-null type \"${(0, _inspect.inspect)(\n          argType,\n        )}\" ` + 'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = (0, _valueFromAST.valueFromAST)(\n      valueNode,\n      argType,\n      variableValues,\n    );\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" has invalid value ${(0, _printer.print)(\n          valueNode,\n        )}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","coerceVariableValues","schema","varDefNodes","inputs","onError","coercedValues","varDefNode","varName","variable","name","value","varType","_typeFromAST","typeFromAST","type","_definition","isInputType","varTypeStr","_printer","print","_GraphQLError","GraphQLError","nodes","Object","prototype","hasOwnProperty","call","defaultValue","_valueFromAST","valueFromAST","isNonNullType","_inspect","inspect","_coerceInputValue","coerceInputValue","path","invalidValue","error","prefix","length","_printPathArray","printPathArray","message","originalError","getArgumentValues","def","node","variableValues","_node$arguments","argumentNodes","arguments","argNodeMap","_keyMap","keyMap","arg","argDef","args","argType","argumentNode","valueNode","isNull","kind","_kinds","Kind","NULL","VARIABLE","variableName","undefined","coercedValue","defineProperty","getDirectiveValues","directiveDef","_node$directives","directiveNode","directives","find","directive","getVariableValues","options","errors","maxErrors","coerced","push"]
}
